C GRAPHICS.FOR - COLLECTION OF SUBROUTINES USED BY FILMAN AND SPECTR        

C  FOR GRAPHICS TASKS

C  *******

	include 'fgraph.fi'

C GRAPHMODE DETERMINES VIDEO ENVIRONMENT AND SETS SCREEN DIMENSIONS

	SUBROUTINE GRAPHMODE_ON(MAXX,MAXY,NROW,NCOL,NBITS,NCOLORS)

	include 'fgraph.fd'

	RECORD / videoconfig / vc 

	logical lores

	COMMON /ARERR/ IERR

C     DATA LORES/.TRUE./  ! .TRUE. --> LOW RES, .FALSE. --> HIGH

	DATA LORES/.FALSE./

	iDummy = displaycursor($GCURSOROFF)

	CALL getvideoconfig(vc)

	iAdapter = vc.adapter

	IF ((iAdapter .EQ. $EGA) .OR. (iAdapter .EQ. $OEGA)) THEN

	   IF (vc.memory .GT. 64) THEN

		iMode = $ERESCOLOR

	   ELSE

		iMode = $HRES16COLOR

	   END IF



	ELSE IF ((iAdapter .EQ. $VGA) .OR. (iAdapter .EQ. $OVGA)) THEN

	   iMode = $VRES16COLOR



	ELSE IF (iAdapter .EQ. $SVGA) THEN

	   if(lores)then

	    iMode =$VRES16COLOR

	   else  

	    iMode =$XRES256COLOR

	   endif  



	ELSE

	   PAUSE 'No graphics mode available.'

	   IERR=1

	   RETURN



	END IF



	CALL clearscreen($GCLEARSCREEN)

	iDummy = setvideomode(iMode)

	iDummy = displaycursor($GCURSOROFF)

	CALL getvideoconfig(vc)

	ISTAT = REGISTERFONTS('C:\F32\LIB\TMSRB.FON')

	ISTAT = REGISTERFONTS('C:\F32\LIB\MODERN.FON')

	MAXX=VC.NUMXPIXELS

	MAXY=VC.NUMYPIXELS

	NROW=VC.NUMTEXTROWS

	NCOL=VC.NUMTEXTCOLS

	NBITS=VC.BITSPERPIXEL

	NCOLORS=VC.NUMCOLORS

	RETURN

	END

	

	SUBROUTINE GRAPHMODE_OFF

	include 'fgraph.fd'

	CALL CLEARSCREEN($GCLEARSCREEN)

	cRows = setvideomode($DEFAULTMODE)

	CALL UNREGISTERFONTS

	RETURN

	END



		

		

C SETUP.FOR- SUBROUTINE TO ALLOCATE PLOT REGIONS FOR MULTICHANNEL

C PLOTS. 

	SUBROUTINE SETUP(IXDIM,IYDIM,NTR,CLABEL,NC,  ! PASSED

     + MODE,ISTART,XDIM,YDIM)                         ! RETURNED

      PARAMETER (MARGIN=10)

	DIMENSION ISTART(64,2),MISC(10),MAP(20)

	CHARACTER*24 CLABEL(NC),CTEMP24     ! FOR PS VERSION

	CHARACTER*1 CTEMP1(24)

	EQUIVALENCE (CTEMP24,CTEMP1)  ! HANDY FOR CHAR-BY-CHAR OPS

C DEFINE TOTAL AVAILABLE SCREEN DIMENSIONS FOR THE PLOTS

	XTOT=FLOAT(IXDIM)

	ITXT=3*IYDIM/NTR

	YTOT=FLOAT(IYDIM-ITXT-1)  ! ALLOWS FOR 3 LINES OF TEXT 

	IF(MODE)1001,1001,1002         ! AT THE SELECTED RESOLUTION

1001    IF(NC.GT.1)GO TO 1000

	MODE=1

	GO TO 1002

1000    WRITE(*,101)

101     FORMAT('$   PLOT MODE:1=SINGLE/2=MULTICHANNEL >'\)

	READ(*,*)MODE

1002    ISTART=0

	GO TO (1,4)MODE

1     IX0=MARGIN+1

	IY0=IYDIM-2*MARGIN-1

	DO 2 I=1,NC

	ISTART(I,1)=IX0

2     ISTART(I,2)=IY0

	XDIM=XTOT-2*MARGIN

	YDIM=YTOT-2*MARGIN

	RETURN

4     NMISC=0           ! NON-SCALP CHANNELS

	DO 10 I=1,NC

	CTEMP24=CLABEL(I)

	CALL READLAB(CTEMP24,ISTART(I,1),ISTART(I,2))

	IF(ISTART(I,1).NE.0)GO TO 10

	NMISC=NMISC+1

	MISC(NMISC)=I

10    CONTINUE

C PATCH FOR OLD DATAFILES WITH FEW CHANS & NON-STANDARD LABELS

	IF(NMISC.LT.NC)GO TO 14

	DO 12 I=1,NC

	ISTART(I,1)=I

	ISTART(I,2)=1

12      CONTINUE

	NR=NC

	NCOL=1

	GO TO 46

C DETERMINE NUMBERS OF ROWS & COLUMNS TO PLOT

C DO ROWS FIRST; THEY'LL INCLUDE ANY NON-SCALP CHANNELS

14      MAP=0

	ASSIGN 201 TO NEXT

	NR=0        !COUNTER FOR ROWS OF SCALP CHANNELS

	DO 15 I=1,NC

	K=ISTART(I,1)

	IF(K.EQ.0)GO TO 15      ! NON-SCALP CHANNEL

	IF(MAP(K).EQ.1) GO TO 15      ! DUPLICATE ROW

	MAP(K)=1

	NR=NR+1     

15    CONTINUE

C FINISH THE POSITION TABLE

16    NEWCOORD=1

	DO 20 I=1,20

	IF(MAP(I).EQ.0)GO TO 20

	MAP(I)=NEWCOORD

	NEWCOORD=NEWCOORD+1

20    CONTINUE

	GO TO NEXT

201   ASSIGN 31 TO NEXT

C NOW ASSIGN FINAL PLOT ROW POSITIONS TO THE SELECTED SCALP CHANNELS

	DO 25 I=1,NC

	K=ISTART(I,1)

	IF(K)25,25,22

22    ISTART(I,1)=MAP(K)

25    CONTINUE

C NOW PROCESS THE COLUMN COORDINATES IN THE SAME WAY

	MAP=0

	NCOL=0

	DO 30 I=1,NC

	K=ISTART(I,2)

	IF(K.EQ.0)GO TO 30      ! ALREADY COUNTED BY ROW ROUTINE

	IF(MAP(K).EQ.1)GO TO 30 ! DUPLICATE

	MAP(K)=1

	NCOL=NCOL+1

30    CONTINUE

	GO TO 16

C NOW ASSIGN COLUMN POSITIONS TO THE SCALP CHANNELS

31    DO 35 I=1,NC

	K=ISTART(I,2)

	IF(K)35,35,33

33    ISTART(I,2)=MAP(K)

35    CONTINUE

C DETERMINE WHERE TO PUT THE MISCELLANEOUS ONES:

C WILL THEY FIT IN LAST SCALP ROW?

	I2MAX=0

	DO 40 I=1,NC

	IF(ISTART(I,1).LT.NR)GO TO 40 ! LOOK AT LAST ROW ONLY

	IF(ISTART(I,2).LT.I2MAX)GO TO 40    !FIND BIGGEST COLUMN INDEX

	I2MAX=ISTART(I,2)

40    CONTINUE

	IF((NCOL-I2MAX).LT.NMISC)GO TO 42   ! DON'T FIT

	NM1=I2MAX+1 ! FIRST FREE COLUMN

	GO TO 44

C SEPARATE ROW FOR MISC

42    NR=NR+1

	NM1=1

C SET ROW, COLUMN POSITIONS FOR MISC. CHANNELS

44    DO 45 I=1,NMISC

	ISTART(MISC(I),1)=NR

	ISTART(MISC(I),2)=NM1

45    NM1=NM1+1

C FINALLY, TRANSLATE PLOT ROW,COLUMN POSITIONS TO SCREEN  COORDINATES,

C DETERMINE XDIM & YDIM , AND RETURN

46      IXT=XTOT/FLOAT(NCOL)

	XDIM=IXT-2*MARGIN   ! LEAVING ROOM FOR Y-LABELS + SPACER

	IYT=YTOT/FLOAT(NR)

	YDIM=IYT-2*MARGIN   ! LEAVING ROOM FOR X-LABELS + SPACER

	DO 50 I=1,NC

	IR=ISTART(I,1)    ! PLOT ROW

	IC=ISTART(I,2)-1  ! PLOT COLUMN

	ISTART(I,2)=ITXT+IR*IYT-2*MARGIN   ! VERTICAL STARTPOINT

	ISTART(I,1)=MARGIN+IC*IXT          ! HORIZONTAL STARTPOINT

50    CONTINUE

	RETURN

	END





C SUBROUTINE TO SELECT LABELING SCHEME FOR ABSCISSA

	SUBROUTINE LABSCL(ITYPE,N,DX,XDIM,IXTOT,STEP,XINT)

	PARAMETER (MARGIN=10)

	GO TO (1,5,5)ITYPE

C TIME-DATA

1     SEC=FLOAT(N)*DX

	STEP=SEC/64.

	XINT=8.0*STEP

	GO TO 20

C FREQUENCY DATA 

5     STEP=.125

	XINT=1.0

C CANONICAL VALUES ARE FOR <16HZ CASE; ADJUST FOR OTHERS

	IRANGE=FLOAT(N-1)*DX

	IR=8

	FACT=.5

	DO 10 K=1,8

	FACT=2*FACT

	IR=2*IR

	IF(IR-IRANGE)10,15,15

10    CONTINUE

15    STEP=STEP*FACT

	XINT=XINT*FACT

20    IF(XDIM.GE.(IXTOT-MARGIN))GO TO 30

C CORRECT FOR PLOT'S ACTUAL LENGTH IN MULTICHANNEL CASES

	ISIZE=IXTOT/(INT(XDIM)+MARGIN)      ! INTEGER MULTIPLIER

C CHANGE IT TO NEXT HIGHER POWER OF 2      

	M=-1

21    M=M+1

	IF(2**M.LT.ISIZE)GO TO 21

	FSIZE=2.0**M

	XINT=XINT*FSIZE

	STEP=STEP*FSIZE

30    RETURN

	END

C ***************

C SUBROUTINE TO EXTRACT POSITION INFO FROM FILMAN LABEL FIELDS; MAY

C NEED TIGHTENING UP TO CHECK FOR IMPOSSIBLE VALUES ETC

	SUBROUTINE READLAB(CLABEL,IROW,ICOL)

      INCLUDE 'MAX.INC'
	PARAMETER (NCMAX=ICHMAX)

C IF NOT A SCALP CHANNEL SETS IROW, ICOL TO 0

	CHARACTER*24 CLABEL

	CHARACTER*1 ITBL(11)

	DATA ITBL/'0','1','2','3','4','5','6','7','8','9',','/

	IROW=0

	ICOL=0

	ND=0

	ID1=0

	ID2=0

	IF(CLABEL(1:1).EQ.'*')RETURN    ! (OLD CONVENTION FOR NON-SCALP)

	L=LEN_TRIM(CLABEL)

	DO 20 I=1,L

	DO 15 J=1,11

	IF(CLABEL(I:I).NE.ITBL(J))GO TO 15

5     GO TO(6,6,6,6,6,6,6,6,6,6,12)J

6     GO TO(7,8,9)ND+1

7     ID1=10*ID1+J-1

	GO TO 20

8     ID2=10*ID2+J-1

	GO TO 20

9     RETURN      ! MORE THAN 2 #'S  (?)

12    IF(ID1.NE.0)ND=ND+1

15    CONTINUE

C LAST CHARACTER WAS NOT A DIGIT OR COMMA; IF BOTH DIGITS ALREADY FOUND,

C  EXIT THE LOOP

	IF(ID2.NE.0)GO TO 25

20    CONTINUE

	IF(ID2.EQ.0)RETURN

C ROUGH CHECK FOR WILD NUMBERS

25    IF(ID1*ID2.GT.NCMAX)RETURN

	IROW=ID1

	ICOL=ID2

	RETURN

	END





