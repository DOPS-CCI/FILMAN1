C MAIN ROUTINE TO FIT MULTICHANNEL AR MODELS PER FRANASZCZUK ET AL,
C CALCULATE CROSS-SPECTRA AND DERIVED MEASURES, AND WRITE FILMAN OUTPUT
C FILES. ALSO ALLOWS POST-PROCESSING OF THE OUTPUT FILES FOR PLOTS AND
C (LATER) SELECTION OF SPECIFIED FREQUENCY BANDS.
	SUBROUTINE MULTAR
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	INCLUDE 'MULTAR.INC'
	INCLUDE 'MAX.INC'
C MAXAR  - MAXIMAL AR MODEL ORDER
C MCHANS - MAXIMAL NUMBER OF CHANNELS (SOME SUBROUTINES
C          REQUIRE WORKARRAY)
C MNPTS  - NUMBER OF CALCULATION POINTS IN FREQUENCY DOMAIN (POWER SP)
C MKN    - NUMBER OF FUNCTIONS CALCULATED IN AR_SPECT
C IFADNR - NUMBER OF FAD PARAMETERS (B,BETA,OMEGA,FI)
C INTBMX - MAXIMAL NUMBER OF BORDERS OF DTF INTEGRATION RANGES
	REAL X,XV,XI,WYN,HDR,WYN2,WYN2S
C	REAL WORK,X,XV,XI,WYN,HDR
	DIMENSION WORK[ALLOCATABLE](:,:),WINDOW[ALLOCATABLE](:,:)
	DIMENSION Q[ALLOCATABLE](:,:)
	DIMENSION V[ALLOCATABLE](:,:)
	DIMENSION WYN[ALLOCATABLE](:,:,:,:)
	DIMENSION ERP[ALLOCATABLE](:,:)
	DIMENSION WYN2[ALLOCATABLE](:,:,:,:),WYN2S[ALLOCATABLE](:,:,:,:)
	LOGICAL WHICH(MKN+1),usevss
	CHARACTER*24 CLABEL(ICHMAX)
	CHARACTER*64 INPFIL
	DIMENSION ICLABS(6,ICHMAX),MLABS(6,MKN),MLABS1(6*MKN),HDR(15)
	COMMON IFLAG1,IFLAG2,IFLAG3,KNT,ISZ,ICHAN(MCHANS)
	COMMON/COHPAR/WHICH,RMINF,RMXF      ! LAST 2 DOUBLE PRECISION
	COMMON/DEV/ITI
	COMMON/STDFIL/INPFIL
	COMMON/STDFIL2/ OOK,GIVEN
	DATA GIVEN /.FALSE./
	LOGICAL OOK,GIVEN
	COMMON/FLDES/ NG,NA,NC,ND,NF,NL,NR,IS,IBUF(108)
	COMMON/FLDESO/ NGO,NAO,NCO,NDO,NFO,NLO,NRO,ISO,IBUFO(IOMAX)
	INTEGER IBUFO2(IOMAX),IBUFL(8)
	COMMON /ARERR/ IERR
	common /vss/ usevss   ! for rescaling spectral matrix
	EQUIVALENCE (ICLABS,CLABEL),(X,IX),(WHICH,HDR),(MLABS,MLABS1)
	DATA MLABS1/'SPEC','TRAL',' MAT','RIX/','REAL','    ',
     1             'SPEC','TRAL',' MAT','RIX/','IMAG','    ',
     2             'COHE','RENC','E MA','TRIX','/R  ','    ',
     3             'COHE','RENC','E MA','TRIX','/I  ','    ',
     4             'DIRE','CTED',' XFR',' MAT','RIX ','    ',
     5             'RESI','DUAL',' VAR','IANC','ES  ','    ',
     6             'NON-','NORM','ALIZ','ED D','TF  ','    ',
     7             'dDTF',' MAT','RIX ','    ','    ','    '/
      LOGICAL wrtout
      SAVE mode,iplot,wrtout,IORD0,NXEQ,NID,NDO1,N1,NHDR,NCHANS,IC
      SAVE WORK,Q,V,WYN,WINDOW,ERP,WYN2,WYN2S
      SAVE HDR,NPTS,NIORD,KN,IORD,M,LOC,IO
      SAVE ICRN
!	COMMON/CNTR2/COUNT,CNTFLG
	EQUIVALENCE (gvlabs,IGVLABS)
	integer*4 GVLABS
	parameter (IMGW=6,FUNPOS=2,IBTGW=2)
	DIMENSION GVLABS(6,IMGW+IBTGW),IGVLABS(6*(IMGW+IBTGW))
	DATA IGVLABS/'DEST','INAT','ION ','CHAN','NEL ','    ',
     2             'FUNC','TION',' TYP','E OU','T OF','    ',
     3             'MODE','L OR','DER ','    ','    ','    ',
     4             'FREQ','UENC','Y RA','NGE ','STAR','T   ',
     5             'FREQ','UENC','Y RA','NGE ','END ','    ',
     6             'TRIA','L NU','MBER','    ','    ','    ',
     7             'WIND','OW N','UMBE','R   ','    ','    ',
     8             'SIGN','IFIC','ANCE',' LEV','EL  ','    '/
	INTEGER*4 IGVNAME(6)
	character*24 GVNAME
	character*20 FUNCNM
	EQUIVALENCE (IGVNAME,GVNAME),(FUNCNM,GVLABS(1,FUNPOS))!FUNCTION TYPE' for searching
      CHARACTER*4 CKN
      equivalence (CKN,GVLABS(6,FUNPOS)) ! 'FUNCTION TYPE' will contain number
      REAL*4 ARMINF,ARMXF
      INTEGER*4 IRMINF,IRMXF
      EQUIVALENCE (ARMINF,IRMINF),(ARMXF,IRMXF)
      INTEGER*4 IMUID(5),IINPNM(16)
	DATA IMUID/'MULT','AR O','UTPU','T FO','R   '/
	COMMON /IMU/IMUID,IsOutput,OUTFOR
	EQUIVALENCE (IINPNM,INPFIL)
	save ITRLN,ITRMX,J1,J2,NGO2,II1
	CHARACTER*7 CCN
	COMMON /MULTRD/ ITURN,NTRNS
	save IWNSZ,IWNSHF,IPLSZ,IBTNUM,IWNMAX,IBUFO2
	LOGICAL DoSDTF,DoBoots,NormT,NormR,EndPlot,ZerBoot
	SAVE DoSDTF,DoBoots,CCN,NormT,NormR,ZerBoot
	DIMENSION R1M(:,:),R2(:,:),IPIV(:),RCONST(:,:,:),SWYN(:,:,:,:,:)
	DIMENSION ZWYN(:,:,:,:)
	Allocatable R1M,R2,IPIV,RCONST,SWYN,ZWYN
	REAL SWYN,ZWYN
	SAVE R1M,R2,IPIV,IALG,RCONST
	SAVE IROWSTART,IROWEND,ICOLSTART,ICOLEND
	PARAMETER (LPRVL=7)
	REAL PRVL(LPRVL),SLVL(LPRVL)
	DATA PRVL /0.01, 0.05, 0.1, 0.5, 0.9, 0.95, 0.99/
	PARAMETER (NLEVS=6)
	REAL VLEVS(NLEVS)
	DATA VLEVS /0.5, 0.8, 0.9, 0.95, 0.98, 0.99/
	ALLOCATABLE LIST(:)
	SAVE VLEVS,IBMX,ISHMTN,ZWYN,ISLLEV,NoSWYN,SWYN
      COMMON /SPGSS/ ISPGON
      LOGICAL ISPGON,IsOutput,NoSWYN,StdDev
      EXTERNAL PUTSTD,ZBWRIT,SDWRIT,FUN,BOWRIT,AVWRIT
      REAL SPECMX,FINDMAXSPECT
      COMMON /FORDLG/ NCHANS,ITRMX
      DATA NoSWYN /.TRUE./
      CHARACTER*52 OUTFOR
      CHARACTER*30 ADDTXT(6)
      COMMON /PLTXT/ ADDTXT
      LOGICAL WPPSF,CMMP,WTK,WOFIF,ISDM
      SAVE WPPSF,CMMP,NGQ,WTK,EndPlot,WOFIF,ISDM
	CHARACTER*5 CMMTITLES(MKN-2)
	DATA CMMTITLES /'POWSP','COHS ','DTF  ','V    ',
     $                'NNDTF','DDTF '/
      COMMON /GBLMAX/ USEGBM
      LOGICAL USEGBM
      COMMON /CPN/ CURPROCNAME
      CHARACTER*10 CURPROCNAME
      CHARACTER*1024 OUTNAME
      CHARACTER*1024 OUTFNM
	INTEGER*4 COUNT,CNTFLG,DUMMY(IPREC),JREC
	COMMON/CNTR1/COUNT,CNTFLG,DUMMY,JREC

	IF(IFLAG1) 1,40,90  
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   IFLAG = -1	
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C INITIALIZATION SECTION- FIND OUT WHAT'S TO BE DONE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
1     NDO1=NDO
      CURPROCNAME='MULTAR'
      ICRN=0
      NGO=NGO+IMGW   ! IMGW new GROUP VARIABLES (see IGVLABS)
	N1=NGO+NAO+1
	DO 57,II=1,MKN+1
57    WHICH(II)=.FALSE.
!	NHDR=15     ! THIS MAY CHANGE LATER
      IERR=0
	IPLOT=0
	RMINF=0D0               
      RMXF=5D-1*DBLE(IS)      
      IWNSZ=ND/2
      IWNSHF=1
      ITRMX=NR/NC
C      IPLSZ=MIN(ITRMX,200)
      IPLSZ=MIN(ITRMX,100)
      IBTNUM=50
C      IBTNUM=500
      IROWSTART=1
      IROWEND=NCO
      ICOLSTART=1
      ICOLEND=NCO
	NCHANS=NCO  ! # SELECTED INPUT CHANNELS
      ZerBoot=.FALSE.
C      CALL CheckIfOutput(IBUF(91),IMUID,IsOutput,OUTFOR)
      ADDTXT=''
      IAVG=0
	MODE=1
      IF(IsOutput)MODE=2      
      WPPSF=.FALSE.   ! Write Post-Processing SYS File
      CMMP=.FALSE.  ! Cumulative plot
      WTK=.TRUE.    ! Plots wait for keyboard input
      EndPlot=.FALSE. ! Stop plotting results for successive trials
      USEGBM=.FALSE.  ! Same maximum for succesive trials' plots
C      ISHMTN=1  ! number of baseline est. data shuffling method
      ISDM=.FALSE. ! Include SYSTAT DTF measures
      usevss=.FALSE.
      normT=.FALSE.
      I1NG=0
      IF(MODE.EQ.2)THEN
        DO 421,II1=1,NG
        DO 422,II2=1,6
422     IGVNAME(II2)=IBUF((II1-1)*6+II2)
        IF(INDEX(GVNAME,'DESTINATION CHANNEL').NE.0)I1NG=II1
        IIMO=INDEX(GVNAME,"MODEL ORDER")
        IF(IIMO.ne.0)then
            CALL GETREC(1)
            IOPOS=117+6*(NG+NC)+II1-1
            IORD=DUMMY(IOPOS)
            GOTO 424
        endif
421     CONTINUE
        usevss=.FALSE.
        GOTO 425        
424     usevss=IORD.GT.100
        IF(usevss)THEN
            IORD=IORD-100
        ENDIF
425     CONTINUE        
      ENDIF
      
	CALL DoMultarParamsDialog(MODE,IPLOT,wrtout,IORD0,
     $                          DoSDTF,IWNSZ,IWNSHF,
     $                          DoBoots,IPLSZ,IBTNUM,
     $                          IALG,NormT,NormR,
     $                          ZerBoot,IBMX,ISHMTN,ISLLEV,
     $                          WPPSF,CMMP,WOFIF,ISDM)
      IF(WPPSF)THEN
        CALL DoMultarOutputDialog(RMINF,RMXF)
        OUTNAME=OUTFNM(CURPROCNAME)
        IF(MODE.EQ.2 .AND.
     $      INDEX(OUTNAME,'.mlt',BACK=.FALSE.).NE.
     $          INDEX(OUTNAME,'.mlt',BACK=.TRUE.))THEN
              LTRO=INDEX(OUTNAME,'.mlt',BACK=.TRUE.)
              OUTNAME(LTRO:LTRO+3)='.syd'
              OUTNAME(LTRO+4:LEN_TRIM(OUTNAME))=' '
        ELSE
            LTRO=LEN_TRIM(OUTNAME)
            OUTNAME(LTRO-2:LTRO)='syd'
        ENDIF
        CALL ADVMOPEN(OUTNAME)
      ENDIF  
      IF(CMMP)CALL STARTCMM(MKN-2,CMMTITLES)
C      IBMX=IBTNUM
C      OOK=(wrtout.AND..NOT.DoSDTF) ! Don't ask for name in PUTOPN, open file
C      GIVEN=(wrtout.AND.DoSDTF) ! Don't ask for name in PUTOPN, do not open file
      OOK=.FALSE.
      GIVEN=.FALSE.
      IF(.NOT.WOFIF) IFLAG3=0
      IF(MODE.EQ.2)ZerBoot=.FALSE.
      NGQ=NG
      IF(MODE.EQ.2)THEN
        IF(I1NG.NE.0)THEN
            NGQ=I1NG-1
        ELSE
            NGQ=2
        ENDIF    
      ENDIF  
      
4     IF(WPPSF)GOTO 5 ! Whatever MODE is
      GO TO(5,20)MODE

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C        MODE = 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C RAW DATA INPUT; STORE CHANNEL LABELS RIGHT AWAY
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
5     IERR=0      
	IC=1
	ITRLN=1
C	ITRMX=1
C	ITRMX=NR/NC
	IWINMX=1
	NTRNS=IWINMX
	if(NormR)NTRNS=NTRNS+1
	DO 3 I=1,NCO
	K=6*(NG+ICHAN(I))-5
	DO 3 J=1,6
	ICLABS(J,I)=IBUF(K)
3     K=K+1
1071  NPTS=MNPTS              ! DITTO
	ASSIGN 77 TO LOC        ! XFR POINT AFTER PLOT

C GET NUMBER OF PANELS TO BE USED IN WYN
12    KN=0
	DO 13 I=1,MKN
	IF(WHICH(I))KN=KN+1
13    CONTINUE
      if(wrtout)goto 131
	IFLAG3=0   !  Do not generate output file
      if(WPPSF)goto 131
	ISZ=NGO+NAO
C	return     
	goto 25     
131   NFO=3      ! Output FLOAT*4 type
!	NCO=KN
	NCO=NCHANS
!	NDO=NHDR+6*NCHANS+NPTS*NCHANS*NCHANS   ! HDR+LABELS+DATA
      NDO=NPTS
      NLO=NPTS+NGO+NAO
	ISZ=NGO+NAO+NDO
!	HDR(NHDR-3)=NPTS
!	HDR(NHDR-2)=NCHANS
!	HDR(NHDR-1)=IORD
!	HDR(NHDR)=KN
      write(CKN,'(I4)')KN
	
C INSERT NEW GROUPING VARIABLES NAMES INTO OUTPUT FILE	
C	J=109+6*2
	J=109+6*NG
	do 1601,IW=1,IMGW-1  !  new Grouping Variables
	DO 1601,I=1,6
	IBUFO(J)=GVLABS(I,IW)
1601  J=J+1
      IF(DoSDTF)THEN
        IW=7           ! 'WINDOW NUMBER'
      ELSE
        IW=6           ! 'TRIAL NUMBER'
      ENDIF
	DO 1611,I=1,6
	IBUFO(J)=GVLABS(I,IW)
1611  J=J+1

C Preparing IBUFO2 - 2nd header for additional output files
      NGO2=NGO+1
      J2=J
      IBUFO2=IBUFO
      Do 1621,IW=8,IMGW+IBTGW
	DO 1621,I=1,6
	IBUFO2(J2)=GVLABS(I,IW)
1621  J2=J2+1

C INSERT INPUT CHANNEL LABELS INTO OUTPUT FILE
	J=109+6*NGO
	DO 1602 I=1,NCO
	K=6*(NG+ICHAN(I))-5
	DO 1602 I2=1,6
	IBUFO(J)=IBUF(K)
	J=J+1
1602  K=K+1
      J1=J

C Insert original file name as 5th line of description
      J=5*18+1
      DO 1603,I3=1,5
      IBUFO(J)=IMUID(I3)
1603  J=J+1
      DO 1604,I3=1,13
      IBUFO(J)=IINPNM(I3)
1604  J=J+1

C The same for IBUFO2      
C Insert original file name as 5th line of description
      J2=5*18+1
      DO 1623,I3=1,5
      IBUFO2(J2)=IMUID(I3)
1623  J2=J2+1
      DO 1624,I3=1,13
      IBUFO2(J2)=IINPNM(I3)
1624  J2=J2+1

C INSERT INPUT CHANNEL LABELS INTO OUTPUT FILE
	J2=109+6*NGO2
	DO 1622 I=1,NCO
	K=6*(NG+ICHAN(I))-5
	DO 1622 I2=1,6
	IBUFO2(J2)=IBUF(K)
	J2=J2+1
1622  K=K+1

C INSERT MATRIX OUTPUT LABELS INTO OUTPUT FILE
!	DO 17 IW=1,MKN
!	IF(.not.WHICH(IW))GO TO 17
!	DO 16 I=1,6
!	IBUFO(J)=MLABS(I,IW)
!16    J=J+1
!17    CONTINUE

      IF((WOFIF.OR.WPPSF).AND..NOT.DoBoots)THEN
        CALL HDR1VALS(IBUFL,
     $                NGO,NAO,NCO,NPTS,3,NGO+NAO+NPTS,
     $                NCHANS*NCHANS*KN,ISO)
        IF(wrtout)THEN
            CALL INITAV(INPFIL,IBUFL,IBUFO2,108) ! WRITE HEADERS
            !write(4008,*)'+AV'
            CALL AVWRITL(IBUFO(109),J1-109)
        ENDIF
      ENDIF
      IF(.NOT.DoBoots.AND.WPPSF)THEN
        CALL SYSWH(IBUFL,IBUFO2,108,IBUFO(109),J1-109,IBUF,NGQ,ISDM)
      ENDIF
      IF(MODE.EQ.2)GOTO 20

	GO TO 25

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C            MODE = 2
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C POST-PROCESSING OF EXISTING MULTAR OUTPUT FILES; LATER ADD A
C SECTION TO PERMIT SELECTION OF FREQUENCY BANDS FOR OUTPUT TO
C STATISTICAL ROUTINES
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
20    NID=NG+NA
	IFLAG3=0    ! MAY CHANGE
	NXEQ=0
	IC=1
	IERR=0
      
C	ASSIGN 86 TO LOC
	ASSIGN 85 TO LOC
      NCHANS=NC
      DO 21,II1=1,NG
      DO 22,II2=1,6
22    IGVNAME(II2)=IBUF((II1-1)*6+II2)
      II3=INDEX(GVNAME,FUNCNM)
      IF(II3.ne.0)then
        read(GVNAME(21:24),*,err=23)KN
        goto 24
      endif
21    CONTINUE  
      II2=0  ! New grouping variables not found
23    KN=MKN+1
24    NPTS=ND
	DO 31 I=1,NCHANS
	K=6*(NG+ICHAN(I))-5
	DO 31 J=1,6
	ICLABS(J,I)=IBUF(K)
31    K=K+1
C      ALLOCATE(WYN(NPTS,NCHANS,NCHANS,KN),STAT=IERR)
      ALLOCATE(WYN(NPTS,NCHANS,NCHANS,MKN+1),STAT=IERR)
      !write(4009,*)'+WYN'
      IF(IERR.NE.0)THEN
       WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (WYN)'
       IFLAG=1
       IERR=1
       RETURN
      ENDIF 
	IF(MODE.EQ.2)THEN
	  CALL CHKZER(ZerBoot,OUTFOR,NCHANS,CLABEL) ! Later move up to include SDTF
	  !if(ZerBoot)write(4008,*)'+RZ'
	  IF(ZerBoot.AND..NOT.DoSDTF)THEN
	      ALLOCATE(ZWYN(NLEVS,NCHANS,NCHANS,KN),STAT=IERR)
            !write(4009,*)'+ZWYN'
	          IF(IERR.NE.0)THEN
	              WRITE(ITI,*)
     $               'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (ZWYN-31)'
	              IFLAG1=1
	              IERR=1
	          ENDIF
	      ZWYN=0.
	  ELSE    
	      ALLOCATE(ZWYN(0,0,0,0),STAT=IERR)
	  ENDIF
	ENDIF
	ALLOCATE(WYN2(0,0,0,0))
	RETURN

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C       MODE = 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  ALLOCATING WORK ARRAYS
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
25    INQUIRE(ITI,CARRIAGECONTROL=CCN)
C      OPEN(ITI,CARRIAGECONTROL='FORTRAN')
      ALLOCATE(WORK(NCHANS,NDO1),STAT=IERR)
      !write(4009,*)'+WORK'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (WORK)'
	 IFLAG1=1
	 IERR=1
	 GOTO 901
	ENDIF
	IF(NormR)THEN
        ALLOCATE(ERP(NCHANS,NDO1),STAT=IERR)
        !write(4009,*)'+ERP'
	  IF(IERR.NE.0)THEN
	   WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (ERP)'
	   IFLAG1=1
	   IERR=1
	   GOTO 901
	  ENDIF
C	  CALL DZEROF(ERP,NCHANS*NDO1)
	  ERP=0D0
	ENDIF
	ALLOCATE(Q(MAXAR*NCHANS,NCHANS),STAT=IERR)
      !write(4009,*)'+Q'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (Q)'
	 IFLAG1=1
	 IERR=1
	 GOTO 902
	ENDIF 
	ALLOCATE(V(NCHANS,NCHANS),STAT=IERR)
      !write(4009,*)'+V'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (V)'
	 IFLAG1=1
	 IERR=1
	 GOTO 903
	ENDIF 
	ALLOCATE(WYN(NPTS,NCHANS,NCHANS,KN),STAT=IERR)
      !write(4009,*)'+WYN'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (WYN)'
	 IFLAG1=1
	 IERR=1
	 GOTO 904
	ENDIF 
	ALLOCATE(R1M(NCHANS*MAXAR,NCHANS),STAT=IERR)
      !write(4009,*)'+R1M'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (R1M)'
	 IFLAG1=1
	 IERR=1
	 GOTO 905
	ENDIF
	ALLOCATE(R2(NCHANS*MAXAR,NCHANS*MAXAR),STAT=IERR)
      !write(4009,*)'+R2'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (R2)'
	 IFLAG1=1
	 IERR=1
	 GOTO 906
	ENDIF
	ALLOCATE(IPIV(NCHANS*MAXAR),STAT=IERR)
      !write(4009,*)'+IPIV'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (IPIV)'
	 IFLAG1=1
	 IERR=1
	 GOTO 907
	ENDIF
	ALLOCATE(RCONST(NCHANS,NCHANS,MAXAR+1),STAT=IERR)
      !write(4009,*)'+RCONST'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (RCONST)'
	 IFLAG1=1
	 IERR=1
	 GOTO 908
	ENDIF
	ALLOCATE(WYN2(NPTS,NCHANS,NCHANS,KN),STAT=IERR)
      !write(4009,*)'+WYN2'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (WYN2)'
	 IFLAG1=1
	 IERR=1
	 GOTO 909
	ENDIF 
	WYN2=0D0
	ALLOCATE(WYN2S(NPTS,NCHANS,NCHANS,KN),STAT=IERR)
      !write(4009,*)'+WYN2S'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (WYN2S)'
	 IFLAG1=1
	 IERR=1
	 GOTO 909
	ENDIF 
	WYN2S=0D0
	if(ZerBoot)THEN
	  ALLOCATE(ZWYN(NLEVS,NCHANS,NCHANS,MAXAR+1),STAT=IERR)
        !write(4009,*)'+ZWYN'
	  IF(IERR.NE.0)THEN
	      WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (ZWYN)'
	      IFLAG1=1
	      IERR=1
	      GOTO 910
	  ENDIF
	  ZWYN=0.
	ELSE
        !write(4009,*)'+ZWYN'
	  ALLOCATE(ZWYN(0,0,0,0),STAT=IERR)
	ENDIF
      if(DoSDTF)GOTO 500
      ITRMX=1                                        ! NOT SDTF
      NTRNS=1
      ICRN=0 
	RETURN
C-----------------------------------------------------------------------
	
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C   WORK ARRAYS ALLOCATION FOR SDTF, MODE = 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
500   ITRMX=NR/NC
      IF(IWNSHF.LE.0)THEN
        IWNMAX=1
      ELSE
        IWNMAX=(ND-IWNSZ)/IWNSHF+1      !  NUMBER OF WINDOWS
      ENDIF
      ALLOCATE(WINDOW(NCHANS,IWNSZ),STAT=IERR)
      !write(4009,*)'+WINDOW'
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (WINDOW)'
	 IFLAG1=1
	 IERR=1
	 GOTO 910
	ENDIF
	CALL INITSVCORR(INPFIL,IWNSZ,IWNSHF,ITRMAX,NCHANS,IORD,IWNMAX)
      !write(4008,*)'+SV'
	RETURN
C-----------------------------------------------------------------------


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C    IFLAG1 = 0
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C EXECUTION PHASE- NEW DATA OR POST-PROCESSING?
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

40    GO TO(60,50)MODE

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  MODE = 2
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C SECTION TO READ AND PLOT EXISTING MULTAR OUTPUT FILES
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
50    IF(NXEQ)51,51,51  ! Plot layout accepted?
C ON FIRST ENTRY GET HEADER AND LABELS, ALLOCATE WYN, & SET POINTERS
51    NXEQ=1
      ISCH=IBUF(1)
      IDCH=IBUF(II1-1)
      IFUN=IBUF(II1)
      IORD=IBUF(II1+1)
      IRECS=NR/NC/NC/KN    !  Zalezne of formatu!!
      IRMINF=IBUF(II1+2)
      IRMXF=IBUF(II1+3)
      RMINF=ARMINF
      RMXF=ARMXF
      ICRN=IBUF(II1+4)
      IF(IFUN.GT.100)THEN
        DoSDTF=.TRUE.
        GOTO 550
      ENDIF
      IF(IFUN.GT.50)THEN
        IAVG=1
        IFUN=IFUN-50
      ENDIF
      WHICH(IFUN)=.TRUE.
C PUT THIS CHANNEL'S DATA (ALWAYS REAL) INTO WYN
C54	M=2+IMGW+1
54	M=NG+1
      DO 55,IFPT=1,NPTS
	IX=IBUF(M)  ! NB- BYPASSING XVAL
	WYN(IFPT,ISCH,IDCH,IFUN)=X    ! AVOIDING CONVERSION VIA EQUIVALENCE
55    M=M+1
C IF ALL CHANNELS IN, CALL AR_PLOT, O'E RETURN
	IC=IC+1
	IF(IC.LE.NCHANS*NCHANS*KN)RETURN
	IC=1
C	ICRN=ICRN+1
      IF(ZerBoot)THEN
        CALL RDZER(ZWYN,NCHANS,NLEVS,KN,VLEVS(ISLLEV),DoSDTF)
        NPLV=1
C      ELSE
C        NPLV=ISLLEVS
      ENDIF
	GO TO 71    ! i.e., TO THE PLOT STATEMENTS
	
550   CONTINUE
      IF(NoSWYN)THEN
        IWNMAX=ICRN
        NPTS=NPTS/IWNMAX
        ALLOCATE(SWYN(NPTS,NCHANS,NCHANS,IWNMAX,2),STAT=IERR)
        !write(4009,*)'+SWYN'
	  IF(IERR.NE.0)THEN
	      WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (SWYN)'
	      IFLAG1=1
	      IERR=1
	      GOTO 909
	  ENDIF
	  NoSWYN=.FALSE.
	ENDIF
      IFUN=IFUN-100
      INKN=1
      IF(IFUN.EQ.2.OR.IFUN.EQ.4)INKN=2
 	M=NG+1
C 	M=2+IMGW+1
 	Do 552,IWIN=1,IWNMAX
      DO 551,IFPT=1,NPTS
	IX=IBUF(M)  ! NB- BYPASSING XVAL
	SWYN(IFPT,ISCH,IDCH,IWIN,INKN)=X    ! AVOIDING CONVERSION VIA EQUIVALENCE
551   M=M+1
552   CONTINUE
	IC=IC+1
	IF(IC.LE.NCHANS*NCHANS)RETURN
	IF(IFUN.EQ.1.OR.IFUN.EQ.3)THEN
	  IC=1
	  RETURN
	ENDIF
	IC=1
      CALL SDTFPLOT(IPLOT,NCHANS,IFUN-INKN+1,ICRN,IWNMAX,SWYN,WYN,NPTS,
     $              IORD,CLABEL,0,KN,ZerBoot,ZWYN,NLEVS,ISLLEV)
      RETURN
C------------------------------------------------------------------	
	
	
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  MODE = 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  DTF CALCULATIONS FOR REGULAR INPUT DATA
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C FOR NEW TIME INPUT FIRST ASSEMBLE THE DATA MATRIX FOR THIS TRIAL
60    If(DoSDTF)GOTO 600
      DO 65 I=1,NDO1
	CALL XVAL(I,XV,XI)
65    WORK(IC,I)=XV     ! SKIP RECODE HERE
	IC=IC+1
	IF(IC.LE.NCHANS) RETURN
	IC=1
	ICRN=ICRN+1

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                     C
C DATA STORED IN MATRIX FORM; NOW DO THE CALCULATIONS C
C                                                     C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

	IORD=IORD0
	NPLV=ISLLEV
	CALL normaT(WORK,NCHANS,NDO1,NormT)
	if(IORD.LE.0)THEN
	  IORD=MULTAICT(WORK,NCHANS,NDO1,MAXAR,Q,V,IARES)
	  IF(IORD.EQ.0)RETURN
	  IF(IARES.EQ.1)IORD0=IORD ! No more criteria calculations
	ENDIF
C	iord=0
C      if(IORD.LE.0)IORD=MULTAIC2(WORK,NCHANS,NDO1,MAXAR,Q,V,
C     $                           R2,R1M,RCONST,IPIV,1,IALG)
	
	CALL CCORR(WORK,R2,R1M,V,RCONST,NCHANS,NDO1,IORD,IALG)
	CALL SOLVEARYWCOV(R2,Q,R1M,V,NCHANS,IORD,IPIV,IALG)
	CALL AR_SPECTT(Q,V,NCHANS,IORD,NCHANS*MAXAR,WYN,NPTS,KN)
	WYN2=WYN2+WYN
	WYN2S=WYN2S+WYN*WYN
	
	IF(ZerBoot)THEN
	  WRITE(ITI,104)IBMX,' BASELNS',ICRN
        CALL ZERLVB(WORK,NCHANS,NDO1,NPTS,ISHMTN,IBMX,ITI,
     $              R2,R1M,V,RCONST,IORD,IALG,Q,IPIV,KN,WHICH,
     $              ZWYN,NLEVS,VLEVS)
      ENDIF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  DTF PLOT FOR MODE = 1  AND  MODE = 2
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
71	IF(IPLOT.NE.1)THEN
        IF(.NOT.ZerBoot)CALL SHOWPROGRESS(ICRN,NR/NC,70,'#',ITI)
        GO TO 77
      ENDIF
      IF(CMMP)THEN
        ICVAL=0
      ELSE
C        ICVAL=ICRN
        ICVAL=KNT
      ENDIF
      IF((.NOT.CMMP).OR.(WTK).AND..NOT.(CMMP.AND.ICRN.EQ.1))
     $ CALL DoPlotDTFResultsDialog(IROWSTART,IROWEND,ICOLSTART,ICOLEND,
     $                             NCHANS,ICRN,EndPlot,IPLOT,
     $                             CMMP,WTK,.FALSE.,.FALSE.)
!71    WRITE(ITI,109)
!109   FORMAT('$GIVE ROWSTART,ROWEND,COLSTART,COLEND(0 TO END) >'\)      
!	READ(5,'(4I4)')IROWSTART,IROWEND,ICOLSTART,ICOLEND
!	IF(IROWSTART.EQ.0)GOTO LOC
79	IF(EndPlot.AND..NOT.CMMP)GOTO LOC  ! 77 or 85?
C      write(3427,*)ABS(CMPLX(WYN(:,1,1,1),WYN(:,1,1,2)))
C      write(3427,*)ABS(CMPLX(WYN(:,1,2,1),WYN(:,1,2,2)))
C      CALL WYPISZ(3427,ABS(CMPLX(WYN(:,:,:,1),WYN(:,:,:,2))),
C     $NPTS,NCHANS)
	CALL AR_PLOT(WYN,NPTS,NCHANS,KN,IORD,IROWSTART,
     $ IROWEND,ICOLSTART,ICOLEND,CLABEL,ICVAL,
     $ ZerBoot,ZWYN,NLEVS,NPLV,1,MKN,0.,IAVG,.NOT.CMMP,WYN2,.FALSE.,WTK)
      IF(CMMP.AND.ICRN.EQ.1)THEN
        CALL ASK4MAX(IROWSTART,IROWEND,ICOLSTART,ICOLEND,
     $               NCHANS,ICRN,EndPlot,IPLOT,
     $               CMMP,WTK)
        CALL CMCLS
	  CALL AR_PLOT(WYN,NPTS,NCHANS,KN,IORD,IROWSTART,
     $  IROWEND,ICOLSTART,ICOLEND,CLABEL,ICVAL,
     $  ZerBoot,ZWYN,NLEVS,NPLV,1,MKN,0.,IAVG,
     $  .FALSE.,WYN2,.FALSE.,.FALSE.)
        IF(EndPlot.AND..NOT.CMMP)GOTO LOC
      ENDIF
      IF(EndPlot.OR.CMMP)GOTO LOC
	GOTO 71


C WRITE OUTPUT FILE?
77    IF(IFLAG3)85,85,75
C IN THE SDTF CASE WRITING OUTSIDE THE FILMAN MECHANISM


CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  MODE = 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  SDTF CALCULATIONS FOR REGULAR INPUT DATA
C  INPUT FILE READING OUTSIDE THE FILMAN MECHANISM
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
600   CONTINUE  ! SDTF starts here
C Calculating average over realizations (ERP)
      IF(NormR.AND.ITURN.EQ.1)THEN
        DO 663 I=1,NDO1
	  CALL XVAL(I,XV,XI)
663     ERP(IC,I)=ERP(IC,I)+XV     ! SKIP RECODE HERE
	  IC=IC+1
	  IF(IC.LE.NCHANS) RETURN
	  IC=1
	  ITRLN=ITRLN+1
	  IF(ITRLN.LE.ITRMX) RETURN
	  IC=1
	  ITRLN=1
C	  ITURN=ITURN+1
        ERP=ERP/FLOAT(ITRMX)
        RETURN
      ENDIF
      DO 665 I=1,NDO1
	CALL XVAL(I,XV,XI)
665   WORK(IC,I)=XV     ! SKIP RECODE HERE
	IC=IC+1
	IF(IC.LE.NCHANS) RETURN
	
	IF(ITRLN.EQ.1)WRITE(ITI,102)ITRMX,' TRIALS '
	CALL SHOWPROGRESS(ITRLN,ITRMX,70,'#',ITI)
	IORD=IORD0
	IF(NormR)WORK=WORK-ERP
	call normaT(WORK,NCHANS,NDO1,NormT)
	IOVR=IWNSZ-IWNSHF
	DO 700,IWIN=1,IWNMAX
C Assemble window
      if(IWIN.EQ.1)THEN
        do 701,iw=1,IWNSZ
        do 701,ic=1,NCHANS
701     WINDOW(ic,iw)=WORK(ic,iw)        
      else
        IT0=(IWIN-1)*IWNSHF
        DO 702,iw=1,IOVR
        DO 702,ic=1,NCHANS
702     WINDOW(ic,iw)=WINDOW(ic,iw+IWNSHF)
        DO 703,iw=IOVR+1,IWNSZ
        DO 703,ic=1,NCHANS
703     WINDOW(ic,iw)=WORK(ic,IT0+iw)
      endif
C Calculate covariances
	CALL CCORR(WINDOW,R2,R1M,V,RCONST,NCHANS,IWNSZ,IORD,IALG)
C Save results for this window
      CALL SAVECORR(R2,R1M,V,NCHANS,IORD,IWIN,ITRLN,IWNMAX)
700   CONTINUE

C  We just processed the last window
	IC=1
	ITRLN=ITRLN+1
	IF(ITRLN.LE.ITRMX) RETURN
	IC=1
	ITRLN=1
	ITURN=ITURN+1
	
C Actual SDTF calculations
	CALL INITSVDTF(INPFIL,NPTS,IWNSZ,IWNSHF,ITRMX,NCHANS,IWNMAX)
      !write(4008,*)'+SD'
	WRITE(ITI,102)IWNMAX,' WINDOWS'
	DO 710,IWIN=1,IWNMAX
	CALL SHOWPROGRESS(IWIN,IWNMAX,70,'@',ITI)
C Average calculated covariances
	call AVGCORRS(R2,R1M,V,NCHANS,IORD,IWIN,IWNMAX,ITRMX)
C Estimate AR model and functions
	CALL SOLVEARYWCOV(R2,Q,R1M,V,NCHANS,IORD,IPIV,IALG)
	CALL AR_SPECTT(Q,V,NCHANS,IORD,NCHANS*MAXAR,WYN,NPTS,KN)
      CALL SAVEDTF(WYN,NPTS,NCHANS,KN,WHICH,IWIN,ITRLN,IWNMAX)
710   CONTINUE

      IF(.NOT.DoBoots)GOTO 711
C Bootstrap calculations
	WRITE(ITI,103)IBTNUM,IWNMAX
	CALL INITSVBOT(INPFIL,NPTS,IWNSZ,IWNSHF,ITRMX,NCHANS,IWNMAX)
      !write(4008,*)'+SB'
      CALL INITPRCF(INPFIL,NPTS,NCHANS,IWNMAX,LPRVL)
      !write(4008,*)'+PR'
      ALLOCATE(LIST(IPLSZ),STAT=ierr)
      !write(4009,*)'+LIST'
      IF(Ierr.ne.0)THEN
	  WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (LIST)'
	  IFLAG1=1
	  IERR=1
        GOTO 770
      ENDIF
	DO 760,IWIN=1,IWNMAX
	CALL SHOWPROGRESS(IWIN,IWNMAX,70,'B',ITI)
	DO 761,IBO=1,IBTNUM
      CALL RNDLIST(LIST,IPLSZ,ITRMX)
C Average calculated covariances
	call AVGLISTCORRS(LIST,IPLSZ,R2,R1M,V,NCHANS,IORD,IWIN,IWNMAX,ITRMX)
C Estimate AR model and functions
	CALL SOLVEARYWCOV(R2,Q,R1M,V,NCHANS,IORD,IPIV,IALG)
	CALL AR_SPECTT(Q,V,NCHANS,IORD,NCHANS*MAXAR,WYN,NPTS,KN)
761   CALL SAVEBDTF(WYN,NPTS,NCHANS,KN,WHICH,IWIN,IBO,IWNMAX,IBTNUM)
      CALL FINDPRCTILE(PRVL,LPRVL,
     $                 NPTS,NCHANS,KN,WHICH,
     $                 IWIN,ITRLN,IWNMAX,IBTNUM,INPFIL)
760   CONTINUE
      DEALLOCATE(LIST)
      !write(4009,*)'-LIST'
C      CALL CLOSEPRCF
      CALL CLOSESVBOT
      !write(4008,*)'-SB'
770   CONTINUE

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C Plot and/or write SDTF results
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
711   CONTINUE
      ALLOCATE(SWYN(NPTS,NCHANS,NCHANS,IWNMAX,2),STAT=ierr)
      !write(4009,*)'+SWYN'
      IF(Ierr.ne.0)THEN
	  WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (SWYN-711)'
	  IFLAG1=1
	  IERR=1
        GOTO 730
      ENDIF
      IKNLEN=NPTS*NCHANS*NCHANS
      IF(WrtOut)THEN
        CALL HDR1VALS(IBUFO,
     $           NGO,NAO,NCO,NPTS*IWNMAX,3,NGO+NAO+NPTS*IWNMAX,
     $           NCHANS*NCHANS*KN,ISO)
C        CALL INITSD(IBUFO,IBUFO2,J2-1) ! WRITE HEADERS
!        CALL INITSD(IBUFO,IBUFO(9),J1-8-1) ! WRITE HEADERS
        CALL INITSD ! WRITE HEADERS
        !write(4008,*)'+BT'
        CALL SDWRITL(IBUFO(1),8)
        CALL SDWRITL(IBUFO2(1),108)
        CALL SDWRITL(IBUFO(109),J1-109)
        ARMINF=RMINF
        ARMXF=RMXF
      ENDIF
      Do 720,IKN=1,KN
      IF(IKN.EQ.2.OR.IKN.EQ.4)GOTO 722  ! IMAGINARY PARTS
      Do 721,IWIN=1,IWNMAX
      CALL GETDTF1(WYN,NPTS,NCHANS,KN,IKN,WHICH,IWIN,ITRLN,IWNMAX)
      CALL SCOPY(IKNLEN,WYN,1,SWYN(1,1,1,IWIN,1),1)
      IF(IKN.EQ.1.OR.IKN.EQ.3)THEN
        CALL GETDTF1(WYN,NPTS,NCHANS,KN,IKN+1,WHICH,IWIN,ITRLN,IWNMAX)
        CALL SCOPY(IKNLEN,WYN,1,SWYN(1,1,1,IWIN,2),1)
      ENDIF
721   CONTINUE
722   IF(WrtOut)THEN
        IF(IKN.NE.2.AND.IKN.NE.4)THEN
            INKN=1
            IF(IKN.EQ.1.OR.IKN.EQ.3)INKN=2
            IF(WOFIF)
     $        CALL SWRITWYN(IBUFO,IMGW,IORD,IRMINF,IRMXF,2+IMGW+NAO+1,
     $                IWNMAX,IKN,
     $                NGO,0.,SWYN,NPTS,NCHANS,INKN,IWNMAX,1,NPTS,
     $                SDWRIT,NLDUMMY)  ! ANCILLINFO NOT COPIED, SHOULD BE ADDED
        ENDIF
      ENDIF
      IF(WPPSF.AND.IWNMAX.EQ.1)THEN
       CALL ADVANCEDMULTARSAVE(SWYN(:,:,:,1,:),NPTS,NCHANS,KN,ICRN,IORD,
     $                         IBUF,NGQ,ISDM)
      ENDIF
      CALL SDTFPLOT(IPLOT,NCHANS,IKN,ICRN,IWNMAX,SWYN,WYN,NPTS,
     $              IORD,CLABEL,ITRMX,KN,ZerBoot,ZWYN,NLEVS,ISLLEV)
720   CONTINUE

C746   DEALLOCATE(SWYN)	
730   IF(ITURN.LT.NTRNS) RETURN
100   FORMAT($A1\)
101   FORMAT(' ')
102   FORMAT(I5,A8)
103   FORMAT(I7,' BOOTSTRAPS for ',I5,' WINDOWS')
104   FORMAT(I5,A8,' RECORD',I5)
      CALL CLOSESVDTF
      !write(4008,*)'-SD'

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C Write SDTF bootstrap results
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      IF(.NOT.WrtOut)CALL CLOSEPRCF
      !IF(.NOT.WrtOut)write(4008,*)'-PR'
      IF(.NOT.(WrtOut.AND.DoBoots))GOTO 746
C      ILEV=6  ! instead of one value there should be a loop here
      NGOB=NGO
      IF(NGO.EQ.8)NGOB=NGO+1
      IF(NGO.EQ.8)THEN
        J2=109+6*8
        DO 778,I=1,6
        IBUFO2(J2)=GVLABS(I,8)
778     J2=J2+1     
	  J=109+6*NGOB
	  DO 779 I=1,NCO
	  DO 779 I2=1,6
	  IBUFO2(J)=ICLABS(I2,I)
	  J=J+1
779     CONTINUE
      ENDIF
      DO 777 ILEV=1,LPRVL
      CALL HDR1VALS(IBUFO,
     $              NGOB,NAO,NCO,NPTS*IWNMAX,3,NGOB+NAO+NPTS*IWNMAX,
     $              NCHANS*NCHANS*KN,ISO)
      X=PRVL(ILEV)     
      IBUFO(9)=IX
      CALL INITBO(PRVL(ILEV)) ! WRITE HEADERS
      !write(4008,*)'+BO'
      CALL BOWRITL(IBUFO(1),8)
      CALL BOWRITL(IBUFO2(1),108)
      CALL BOWRITL(IBUFO2(109),J-109)
      ARMINF=RMINF
      ARMXF=RMXF
C      CALL REWPRCF
      DO 780,IKN=1,KN
	DO 781,IWIN=1,IWNMAX
781	CALL GETPRCTILE(SWYN,NPTS,NCHANS,IWNMAX,SLVL,LPRVL,ILEV,IKN,KN,IWIN)
      IF(WOFIF)
     $  CALL SWRITWYN(IBUFO,IMGW+1,IORD,IRMINF,IRMXF,2+IMGW+NAO+2,  !czy imgw+1?
     $             IWNMAX,IKN,
     $             NGOB,PRVL(ILEV),SWYN,NPTS,NCHANS,INKN,IWNMAX,1,NPTS,
     $             BOWRIT,NLDUMMY)  ! ANCILLINFO NOT COPIED, SHOULD BE ADDED
780   CONTINUE
777   CALL CLSEBO
!      CALL CLSEBO
!777   write(4008,*)'-BO'
745   CALL CLOSEPRCF
      !write(4008,*)'-PR'
746   DEALLOCATE(SWYN)	
      !write(4009,*)'-SWYN'

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C 
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C WRITE FILMAN OUPUT RECORDS FOR THIS TRIAL (DTF ONLY, NOT SDTF)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
75    IF(DoSDTF)GOTO 85
      ARMINF=RMINF
      ARMXF=RMXF
      IF(WOFIF)
     $  CALL WRITWYN(IBUFO,IMGW,IORD,IRMINF,IRMXF,2+IMGW+1+NAO,ICRN,
     $             NGO,0.,WYN,NPTS,NCHANS,KN,1,NPTS,0,
     $             PUTSTD,NLO)
      IF(WOFIF.AND.ZerBoot)THEN
        IF(ICRN.EQ.1)THEN
            CALL HDR1VALS(IBUFO,    
     $           NGO2,NAO,NCO,1,3,NGO2+NAO+1,
     $           NLEVS*NCHANS*NCHANS*KN*(NR/NC),ISO)
            CALL INITZB(INPFIL,IBUFO,IBUFO2,J2-1) ! WRITE HEADERS
            !write(4008,*)'+ZB'
        ENDIF
        Do 82,IL=1,NLEVS
        CALL WRITWYN(IBUFO,IMGW+1,IORD,IRMINF,IRMXF,2+IMGW+NAO+2,ICRN,
     $               NGO2,VLEVS(IL),ZWYN,NLEVS,NCHANS,KN,IL,IL,0,
     $               ZBWRIT,NLDUMMY)
82      CONTINUE
      ENDIF

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  SDTF WAS ALREADY WRITTEN ELSEWHERE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
85    CONTINUE
      IF(WPPSF)THEN
        CALL ADVANCEDMULTARSAVE(WYN,NPTS,NCHANS,KN,ICRN,IORD,IBUF,NGQ,
     $                          ISDM)
      ENDIF
86    RETURN

CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C  IFLAG = 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C TERMINATION PHASE
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
90    CONTINUE
      IF(CMMP)THEN
C        CALL ShowDoneButton
        I=FOCUSQQ(5)
!        WRITE(ITI,*)'Press a key in THIS window when done'
!        CALL WAITFORKEY
        CALL ShowInfoText('Pause','Press OK when ready')
      ELSEIF(.NOT.(MODE.EQ.2.OR.DoBoots))THEN
        ITRMX=NR/NC
        WYN2=WYN2/ITRMX
        WYN2S=SQRT((WYN2S-ITRMX*WYN2*WYN2)/(ITRMX-1)/ITRMX)
   	  IPLOT=1
   	  StdDev=.TRUE.
971     CALL DoPlotDTFResultsDialog(IROWSTART,IROWEND,ICOLSTART,ICOLEND,
     $                            NCHANS,0,EndPlot,IPLOT,
     $                            .FALSE.,.TRUE.,.TRUE.,StdDev)
	  IF(EndPlot)GOTO 970
	  CALL AR_PLOT(WYN2,NPTS,NCHANS,KN,IORD,IROWSTART,
     $      IROWEND,ICOLSTART,ICOLEND,CLABEL,ICRN,
     $      ZerBoot,ZWYN,NLEVS,NPLV,1,MKN,0.,1,
     $      .NOT.CMMP,WYN2S,StdDev,.TRUE.)
	  GOTO 971
970     IF(wrtout)THEN
            IF(WOFIF)
     $        CALL WRITWYN(IBUFO,IMGW,IORD,IRMINF,IRMXF,2+IMGW+1+NAO,
     $              ITRMX,NGO,0.,WYN2,NPTS,NCHANS,KN,1,NPTS,50,
     $              AVWRIT,NLO)
            CALL CLSEAV
            !write(4008,*)'-AV'
        ENDIF
      ENDIF
      IF(.NOT.NoSWYN)DEALLOCATE(SWYN)
      !IF(.NOT.NoSWYN)write(4009,*)'-SWYN'
      IF(IERR.NE.0)GOTO 3000
      GO TO (91,92)MODE    
91	IERR=0                ! RAW INPUT DATA
      if(DoSDTF)THEN
        DEALLOCATE(WINDOW)
        !write(4009,*)'-WINDOW'
        CALL CLOSESVCORR
        !write(4008,*)'-SV'
        CALL CLSESD
        !write(4008,*)'-BT'
      ENDIF
      IF(ZerBoot)THEN
        DEALLOCATE(ZWYN)
        !write(4009,*)'-ZWYN'
        CALL CLSEZB
        !write(4008,*)'-ZB'
C        IF(MODE.EQ.2)CALL CLSERZ
C        IF(MODE.EQ.2)write(4008,*)'-RZ'
      ELSE
        DEALLOCATE(ZWYN)
        !write(4009,*)'-ZWYN'
      ENDIF
      DEALLOCATE(WYN2S)
910   DEALLOCATE(WYN2)
      !write(4009,*)'-WYN2'
909   DEALLOCATE(RCONST)
      !write(4009,*)'-RCONST'
908   DEALLOCATE(IPIV)      
      !write(4009,*)'-IPIV'
907   DEALLOCATE(R2)
      !write(4009,*)'-R2'
906   DEALLOCATE(R1M)
      !write(4009,*)'-R1M'
905   DEALLOCATE(WYN)
      !write(4009,*)'-WYN'
904   DEALLOCATE(V)
      !write(4009,*)'-V'
903	DEALLOCATE(Q)
      !write(4009,*)'-Q'
      IF(NormR)DEALLOCATE(ERP)
      !IF(NormR)write(4009,*)'-ERP'
902	DEALLOCATE(WORK)
      !write(4009,*)'-WORK'
901   CONTINUE
C	OPEN(ITI,CARRIAGECONTROL=CCN)
	GOTO 3000

92    IERR=0
      IF(ALLOCATED(WYN2))DEALLOCATE(WYN2)
      IF(ZerBoot)THEN
        DEALLOCATE(ZWYN)
        !write(4009,*)'-ZWYN'
C        IF(MODE.EQ.1)CALL CLSEZB
C        IF(MODE.EQ.1)write(4008,*)'-ZB'
        IF(MODE.EQ.2)CALL CLSERZ
        !IF(MODE.EQ.2)write(4008,*)'-RZ'
      ELSE
        DEALLOCATE(ZWYN)
        !write(4009,*)'-ZWYN'
      ENDIF
      DEALLOCATE(WYN)        ! MULTAR OUTPUT
      !write(4009,*)'-WYN'
      
3000  OOK=.FALSE.
      GIVEN=.FALSE.      
      IF(WPPSF)CALL ADVMCLSE
      IF(CMMP)CALL STOPCMM
      RETURN
	END




CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C*************************************************************************
C*************************************************************************
C*************************************************************************
C*************************************************************************
C*************************************************************************
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

!  SPRAWDZIC NORME  !!!!!!!!!!!!

	subroutine normaT(DANE,ICHANS,IRECL,NormT)
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	include 'multar.inc'
!      PARAMETER (MAXAR=20,MCHANS=64,MNPTS=33,MKN=6,IFADNR=4)
C MAXAR  - MAXIMAL AR MODEL ORDER
C MCHANS - MAXIMAL NUMBER OF CHANNELS (SOME SUBROUTINES
C          REQUIRE WORKARRAY)
C MNPTS  - NUMBER OF CALCULATION POINTS IN FREQUENCY DOMAIN (POWER SP)
C MKN    - NUMBER OF FUNCTIONS CALCULATED IN AR_SPECT
C IFADNR - NUMBER OF FAD PARAMETERS (B,BETA,OMEGA,FI)
!      PARAMETER (INTBMX=10)
C INTBMX - MAXIMAL NUMBER OF BORDERS OF DTF INTEGRATION RANGES
C	REAL DANE
	DIMENSION DANE(ICHANS,IRECL)
	dimension vss(mchans)
	logical usevss
	COMMON /DEV/ ITI
	common /vss/ usevss,vss
	LOGICAL NORMT
C	WRITE(ITI,100)
      
      DO 1,IND=1,ICHANS
      S=SUM(DANE(IND,:))/DBLE(IRECL)
      IF(NORMT.OR.usevss)
     $       SS=DSQRT(SUM(DANE(IND,:)*DANE(IND,:))/DBLE(IRECL)-S**2)
      IF(NORMT)THEN
        DANE(IND,:)=(DANE(IND,:)-S)/SS
      ELSE
        DANE(IND,:)=DANE(IND,:)-S
      ENDIF
C      IF(usevss)VSS(IND)=DSQRT(SS)
      IF(usevss)VSS(IND)=SS
!      write(*,*)ind,S,SS
!	do 1,ind=1,ICHANS
!	s=0d0
!	ss=0d0
!	do 2,ip=1,IRECL
!	tmp=DANE(ind,ip)
!	ss=ss+tmp**2
!    2 s=s+tmp
!	ss=dsqrt((ss-s**2/dble(IRECL))/dble(IRECL))
!	vss(ind)=dsqrt(ss)
!	s=s/dble(IRECL)
!	IF(NORMT)THEN
!	  do 11,ip=1,IRECL
!   11   DANE(ind,ip)=(DANE(ind,ip)-s)/ss
!      ELSE
!	  do 12,ip=1,IRECL
!   12   DANE(ind,ip)=(DANE(ind,ip)-s)
!      ENDIF
    1 CONTINUE
	return
  100 format(1h+,79(1h )/1h+,' >>> Normalizing input data')
	end

	SUBROUTINE CCORR(X,RLEFT,RRIGHT,R,RCONST,M,N,IP,IWHAT)
	DOUBLE PRECISION X(M,0:N-1),RCONST(*)
	DOUBLE PRECISION RLEFT((M*IP*(M*IP+1))/2),RRIGHT(M*IP,M),R(M,M)
	INTEGER 	 M,N,IP,IWHAT

      SELECT CASE(IWHAT)
        CASE(1:2)
1	      CALL COUNTCORR(X,RLEFT,RRIGHT,R,M,N,IP,IWHAT)
        CASE(4,8)
	      CALL COUNTCOV(X,RLEFT,RRIGHT,R,RCONST,M,N,IP,IWHAT)
        CASE DEFAULT
            WRITE(*,*)'Unknown algorithm number: ',IWHAT
            WRITE(*,*)'Using Yule-Walker'
            IWHAT=1
            GOTO 1
      END SELECT
      END
      
      SUBROUTINE SHOWPROGRESS(I,IVMX,ISCRMX,CHR,ITI)
      COMMON /SPGSS/ ISPGON
      DATA ISPGON /.TRUE./
      LOGICAL ISPGON
      CHARACTER*1 CHR
      
      IF(.NOT.ISPGON)RETURN
      IF(IVMX.LE.ISCRMX)THEN
        WRITE(ITI,100)CHR
      ELSEIF(I.EQ.1)THEN
        WRITE(ITI,100)CHR
      ELSEIF(I.EQ.IVMX.AND.ISCRMX.GT.1)THEN
        WRITE(ITI,100)CHR
      ELSE
        A=FLOAT(ISCRMX-1)/FLOAT(IVMX-1)
        B=1.-A
        RI=FLOAT(I)
        IF(FLOOR(A*RI+B).NE.FLOOR(A*(RI-1.)+B))
     $       WRITE(ITI,100)CHR
      ENDIF
      IF(I.EQ.IVMX)WRITE(ITI,101)
100   FORMAT($A1\)
101   FORMAT(1x)
      END
      
      SUBROUTINE HDR1VALS(IBUFO,I1,I2,I3,I4,I5,I6,I7,I8)
      INTEGER*4 IBUFO(*)
      IBUFO(1)=I1
      IBUFO(2)=I2
      IBUFO(3)=I3
      IBUFO(4)=I4
      IBUFO(5)=I5
      IBUFO(6)=I6
      IBUFO(7)=I7
      IBUFO(8)=I8
      RETURN
      END

      SUBROUTINE SWYN2WYN(SWYN,WYN,NPTS,NCHANS,IWNMAX,KN,IKN)
      REAL WYN(NPTS,NCHANS,NCHANS,KN)
      REAL SWYN(NPTS,NCHANS,NCHANS,IWNMAX,*)
      
      IKN2=IKN
      IF(IKN.EQ.1.OR.IKN.EQ.3)IKN2=IKN+1
      Do 1,I1=IKN,IKN2
      I0=I1-IKN+1  ! I1=IKN..IKN2, I0=1..(1 or 2)
      Do 1,I2=1,NCHANS
      Do 1,I3=1,NCHANS
      Do 1,I4=1,NPTS
1     WYN(I4,I3,I2,I1)=SWYN(I4,I3,I2,1,I0)

      RETURN
      END      
      
      
      SUBROUTINE SDTFPLOT(IPLOT,NCHANS,IKN,ICRN,IWNMAX,
     $SWYN,WYN,NPTS,IORD,CLABEL,ITRMX,KN,ZerBoot,ZWYN,NLEVS,ISLLEV)
      REAL SWYN(*)
      REAL WYN(*)
      REAL ZWYN(*)
      LOGICAL ZerBoot,EndPlot
	CHARACTER*24 CLABEL(NCHANS)
      SAVE SPECMX,IRS,IRE,ICS,ICE,EndPlot
      EXTERNAL FUN
      
	IF(IPLOT.NE.1)RETURN
      IRS=1
      IRE=NCHANS
      ICS=1
      ICE=NCHANS
      IF(IKN.EQ.1)THEN
        EndPlot=.FALSE.
        CALL DoPlotDTFResultsDialog(IRS,IRE,ICS,ICE,
     $                              NCHANS,0,EndPlot,IPLOT,
     $                              .FALSE.,.TRUE.,.FALSE.,.FALSE.)
	ENDIF
      IF(EndPlot)RETURN
	IF(IWNMAX.GT.1)THEN
	  CALL SDTF1PLOT(SWYN,NPTS,NCHANS,IKN,IORD,IRS,IRE,ICS,ICE,IWNMAX,
     $               CLABEL,ITRMX)
      ELSE
        CALL SWYN2WYN(SWYN,WYN,NPTS,NCHANS,IWNMAX,KN,IKN)
        IF(IKN.EQ.1)SPECMX=FINDMAXSPECT(WYN,NPTS,NCHANS,KN,1,2,FUN,0)
	  CALL AR_PLOT(WYN,NPTS,NCHANS,KN,IORD,IRS,
     $  IRE,ICS,ICE,CLABEL,ICRN,
     $  ZerBoot,ZWYN,NLEVS,ISLLEV,IKN,IKN,SPECMX,0,
     $  .TRUE.,WYN,.FALSE.,.TRUE.)
      ENDIF
      RETURN
      END      
      
      SUBROUTINE CheckIfMultOutput(IBUF)
      DIMENSION IBUF(5)
      INTEGER*4 IBUF
      LOGICAL IsOutput
      CHARACTER*4 C4
      INTEGER*4 I4
      EQUIVALENCE (C4,I4)
	COMMON /IMU/IMUID,IsOutput,OUTPFOR
      INTEGER*4 IMUID(5)
      CHARACTER*52 OUTPFOR
      
      IsOutput=.TRUE.
      Do 1,I=1,5
      IsOutput=IsOutput.AND.(IBUF(I).eq.IMUID(I))
      IF(.NOT.IsOutput)RETURN
1     CONTINUE
      Do 2,I=6,18
      I4=IBUF(I)
C      IF(C4.EQ.'    ')RETURN
2     OUTPFOR((I-6)*4+1:(I-5)*4)=C4
      RETURN
      END      
      
	SUBROUTINE CHKZER(ZerBoot,OUTFOR,NCHANS,CLABEL)
	LOGICAL ZerBoot,exist
	CHARACTER*(*) OUTFOR
	CHARACTER*128 FNAME
	COMMON /CZBREAD/ IUNIT,IREC,NG,NA,NC,ND,NF,NP,IRSTART,
     $                 ISRC,IDSC,IFUN,ISGL
	INTEGER*4 HEADER(116)
	CHARACTER*72 DESCRIPTION(6)
	EQUIVALENCE (DESCRIPTION,HEADER(9))
	CHARACTER*24 LABEL
	EQUIVALENCE (LABEL,HEADER(1))
	CHARACTER*(*) CLABEL(NCHANS)
	
	ZerBoot=.FALSE.
	FNAME='C:\EEGDATA\'//OUTFOR(1:LEN_TRIM(OUTFOR))//'.ZERLEV.DAT'
	INQUIRE(FILE=FNAME,EXIST=exist)
      IF(.NOT.exist)RETURN
      
      IUNIT=2011
      OPEN(FILE=FNAME,UNIT=IUNIT,STATUS='OLD',FORM='UNFORMATTED',
     $     ACCESS='DIRECT',RECL=1,ERR=10,IOSTAT=iostat)
      IREC=1
      DO 1,I=1,116
      READ(IUNIT,REC=IREC)HEADER(I)
1     IREC=IREC+1
      IF(DESCRIPTION(6)(21:72).NE.OUTFOR .OR. ! file for different input
     $   HEADER(3).NE.NCHANS)                ! different number of chans
     $                             THEN
50      CLOSE(IUNIT)
        RETURN
      ENDIF
      NG=HEADER(1)
      NA=HEADER(2)
      NC=HEADER(3)
      ND=HEADER(4)
      NF=HEADER(5)
      NP=HEADER(6)
      ISGL=0
      DO 2,NI=1,NG
      DO 3,I=1,6
      READ(IUNIT,REC=IREC)HEADER(I)
3     IREC=IREC+1
      IF(LABEL.EQ.'CHANNEL NUMBER')ISRC=NI
      IF(LABEL.EQ.'SIGNIFICANCE LEVEL')ISGL=NI
      IF(LABEL(1:20).EQ.'FUNCTION TYPE OUT OF')IFUN=NI
      IF(LABEL.EQ.'DESTINATION CHANNEL')IDSC=NI
2     CONTINUE
      IF(ISGL.EQ.0)GOTO 50
      DO 7,NI=1,NC
      DO 8,I=1,6
      READ(IUNIT,REC=IREC)HEADER(I)
8     IREC=IREC+1
      IF(LABEL.NE.CLABEL(NI))GOTO 50           ! different chans in file
7     CONTINUE
      ZerBoot=.TRUE.
      IRSTART=IREC
      RETURN
10    IERRCN=iostat
      WRITE(*,*)'File ',FNAME(1:LEN_TRIM(FNAME)),' open error ',IERRCN
      RETURN
	END

      SUBROUTINE RDZER(ZWYN,NCHANS,NLEVS,KN,VLEV,DoSDTF)
      REAL ZWYN(NLEVS,NCHANS,NCHANS,KN)
      LOGICAL DoSDTF,HERE
	COMMON /CZBREAD/ IUNIT,IREC,NG,NA,NC,ND,NF,NP,IRSTART,
     $                 ISRC,IDSC,IFUN,ISGL
	EQUIVALENCE (IVAL,VVAL)
	INTEGER*4 IVAL
	REAL*4 VVAL
      
      IF(DoSDTF)RETURN   ! For now!
      
      Do 10,ITURN=1,NLEVS*NCHANS*NCHANS*KN
      
      DO 1,IG=1,NG
      READ(IUNIT,REC=IREC)IVAL
      IF(IG.EQ.ISRC)IC=IVAL
      IF(IG.EQ.IDSC)JC=IVAL
      IF(IG.EQ.IFUN)JF=IVAL
      IF(IG.EQ.ISGL)HERE=VVAL.EQ.VLEV
1     IREC=IREC+1
      READ(IUNIT,REC=IREC)IVAL
      IREC=IREC+1
      IF(HERE)THEN
        ZWYN(1,IC,JC,JF)=VVAL
C        write(6711,*)ic,jc,jf,vval
        HERE=.FALSE.
      ENDIF
      DO 2,IG=2,ND
      READ(IUNIT,REC=IREC)IVAL
2     IREC=IREC+1
      
10    CONTINUE      
      
      END

      SUBROUTINE CLSERZ
	COMMON /CZBREAD/ IUNIT,IREC
      CLOSE(IUNIT,IOSTAT=iostat)
      RETURN
      END
      
      FUNCTION IRKN(KN)
      IRKN=KN
      IF(IRKN.GE.2)IRKN=IRKN-1
      IF(IRKN.GE.4)IRKN=IRKN-1
      RETURN
      END
      
      SUBROUTINE WYPISZ(IU,Q,NPTS,NCHANS)
      DIMENSION Q(NPTS,NCHANS,NCHANS)
      
      DO 1,I=1,NCHANS
      DO 1,J=1,NCHANS
      WRITE(IU,100)(Q(N,I,J),N=1,NPTS)
1     CONTINUE
100   FORMAT(<NPTS>(1x,G12.5))
      RETURN
      END
      