C FILTER.FOR- FILMAN GENERAL-PURPOSE DIGITAL FILTERING ROUTINE.

C 

C ALLOWS CONSTRUCTION OF WIDE VARIETY OF CHEBY1, CHEB2, & BUTTERWORTH FILTERS

C FOR LOWPASS, HIGHPASS, BANDPASS, OR BANDSTOP FILTERING, BASED ON STEARNS &

C DAVID CHS 6 &7. ALSO IMPLEMENTS BUTTERWORTH HP-LP SEQUENTIAL FILTERING FOR

C IMPROVED BANDPASS RESPONSE, USING DIRECT TYPE II TRANSPOSED FILTER WITH

C COEFFICIENTS GENERATED BY MATLAB M-FILE BHPLP. FORWARD/BACKWARD FILTERING 

C TO ELIMINATE PHASE SHIFTS, AND PREPENDING OF REFLECTED SEGMENTS TO DATA TO 

C MINIMIZE EDGE EFFECTS ARE USED IN ALL FILTERS. ADDITIONAL INITIAL CONDITIONS

C OF FILTER DELAYS (STATES) ARE INCLUDED WITH THE HP-LP FILTER TO REDUCE DC

C OFFSET EFFECTS. OPTIONAL DECIMATION OF FILTER OUTPUT AVAILABLE. 

C POSSIBLE FURTHER ENHANCEMENTS MIGHT INCLUDE ADDITION OF AT LEAST ONE 

C OPTIONAL FILTER SO AS TO PERMIT EXTRACTION OF 2 OR MORE HARMONICS BY 

C COMBINATION OF BRACKETING BANDPASS WITH LIMITING BANDSTOP FILTERS. 

C THIS VERSION OF FILTER.FOR UPDATED ON 10/31/94 

	SUBROUTINE FILTER

	USE IFQWIN

	INCLUDE 'MAX.INC'

	DOUBLE PRECISION COEFF(68),ZI(20)

	DIMENSION WORK(65536),WORK0(0:65535),CF(4),PX(0:4,6),PY(4,6)

      INTEGER*4, SAVE :: IFILT,LS,NDO1,NHFILT,NLFILT,IBH,IAH,IBL,IAL

      INTEGER*4, SAVE :: IOFF,NID,J1,IDEC,NS

      REAL*4, SAVE :: A(4,6),B(0:4,6)

      REAL*8, SAVE :: AH(20),BH(20),AL(20),BL(20),PVH(20),PVL(20)

	COMMON IFLAG1,IFLAG2,IFLAG3,KNT,ISZ,ICHAN(ICHMAX)

	COMMON/FLDESO/ NGO,NAO,NCO,NDO,NFO,NLO,NRO,ISO,IBUFO(IOMAX)

	COMMON/FLDES/ NG,NA,NC,ND,NF,NL,NR,IS,IBUF(IOMAX)

	EQUIVALENCE (WORK,IBUFO(121)),(WORK,WORK0)

	EQUIVALENCE (CF1,CF(1)),(CF2,CF(2)),(CF3,CF(3)),(CF4,CF(4))

      DATA COEFF/2.354683561454284e-01,-3.767493698326856e+00,

     &2.825620273745144e+01,-1.3186227944144e+02,4.285524081846803e+02,

     &-1.028525779643233e+3,1.885630596012593e+3,-2.693757994303704e+03,

     &3.030477743591667e+3,-2.693757994303704e+03,1.885630596012593e+03,

     &-1.028525779643233e+3,4.285524081846803e+2,-1.318622794414401e+02,

     &2.825620273745144e+1,-3.767493698326860e+00,2.354683561454287e-01,

     &1.0000000000000e+00,-1.312062044475557e+01,8.091616678199033e+01,

     &-3.11317907589506e+02,8.36280347764402e+02,-1.663001621342082e+03,

     &2.532175784883837e+3,-3.011292925824418e+03,2.826372262699564e+03,

     &-2.100575460653576e+3,1.231992242724636e+3,-5.641861870570764e+02,

     &1.977546979210619e+2,-5.128559751596994e+01,9.280146051358990e+00,

     &-1.046773745786663e+00,5.544534674583004e-2,3.167334949871758e-09,

     &5.067736452701865e-08,3.800801593456526e-07,1.773707708707661e-06,

     &5.764549115383488e-06,1.383491974138451e-05,2.536401694896994e-05,

     &3.623431268806598e-05,4.076359951454833e-05,3.623431213384265e-05,

     &2.53640177660941e-05,1.383491906636891e-05,5.764549525721918e-06,

     &1.773707565266846e-06,3.800801896547412e-07,5.067735890304514e-08,

     &3.167334918104634e-09,1.0e+00,-8.741921536998909e+00,

     &3.686529043192476e+01,-9.914796985316122e+01,1.89779480477958e+02,

     &-2.73505138673003e+02,3.064294236375896e+02,-2.71838192875174e+02,

     &1.92724299496558e+02,-1.094396453508753e+02,4.95640040774697e+01,

     &-1.769940677261704e+01,4.882031821660637e+00,-1.004856454699e+00,

     &1.454659505001392e-1,-1.322544127515187e-02,5.686386042678259e-04/

      CHARACTER*255 ALINE
      COMMON /CPN/ CURPROCNAME
      CHARACTER*10 CURPROCNAME
      LOGICAL AcceptFilterDialog
	COMMON/DEV/ITI,ILP,IGRAPH

	IF(IFLAG1) 10,30,325

10    NFO=3 ! DECIDED TO MAKE OUTPUT ALWAYS REAL TO AVOID QUANTIZATION
      CURPROCNAME='FILTER'

C MOVE OUTPUT CHANNEL LABELS

	J=6*NGO+109             ! OF LOW-POWER FILTER OUTPUTS

	DO 12 I=1,NCO

	 L=J+5

	 K=6*(NG+ICHAN(I))-5

	 DO 5 I1=J,L

	  IBUFO(I1)=IBUF(K)

5       K=K+1

12     J=J+6

	ISZ=120+NDO

	NID=NGO+NAO

	J1=120-NID+1  ! FIRST WORD OF OUTPUT RECORD

C DESIGN DIGITAL FILTER  

13    CONTINUE
      CALL DoFILTERDialog(IFILT,IBAND,CF,NS,DB,IDEC,ISO)

!      WRITE(*,100)
!
!100   FORMAT('$FILTER TYPE:1=CHEBY1/2=CHEBY2/3=BUTTERWORTH/4=BUTTERWORTH
!
!     & HP-LP >'\)
!
!	READ(*,*)IFILT

	IF(IFILT.LT.1 .OR. IFILT.GT.4)GO TO 13

	IF(IFILT.EQ.4)GO TO 200    !USE MATLAB COEFFICIENTS FOR HP-LP

14    LS=4  ! LENGTH OF THE FILTER SECTIONS FOR STEARNS AND DAVID'S ROUTINES

!	WRITE(*,101) !GET FILTER TYPE FOR STEARNS AND DAVID
!
!101   FORMAT('$CHARACTERISTIC:1=LOWPASS/2=HIGHPASS/3=BANDPASS/',
!
!     + '4=BANDSTOP >'\)
!
!	READ(*,*)IBAND

	IF(IBAND.LT.1 .OR. IBAND.GT.4)GO TO 14

	IF(IBAND.LT.3)LS=2            

!	WRITE(*,102)
!
!102   FORMAT('$LOWER, UPPER CRITICAL FREQS(SEE S&D P.325) >'\)      
!
!	READ(*,*)(CF(I),I=1,4)

C CONVERT TO HZ-SECONDS FOR DESIGN ROUTINES

	DO 16 I=1,4

16     CF(I)=CF(I)/FLOAT(ISO)

!	WRITE(*,103)
!
!103   FORMAT('$# FILTER SECTIONS(.LE.6), REJECTION IN DB(>3) >'\)
!
!	READ(*,*)NS,DB

	CALL SPIIRD(IFILT,IBAND,NS,LS,CF1,CF2,CF3,CF4,DB,B,A,IERR)

	IF(IERR.EQ.0)GO TO 20

!	WRITE(*,104)IERR
!
104   FORMAT(' DESIGN PROBLEM #',I3,'; REDO SPECS(SEE S&D P.153)')
	WRITE(ALINE,104)IERR
      CALL ShowInfoText('Error',ALINE)

	GO TO 13

C PLOT FILTER RESPONSE

20    CALL FILPLOT(NS,LS,B,A,ISO)

!	WRITE(*,107)
!
!107   FORMAT('$OK? >'\)
!
!	READ(*,108)IA
!
!108   FORMAT(A1)
!      CALL GETVALU(2,IVAL,ALINE,'(A)')
!      WRITE(*,'(A)')ALINE
!      READ(ALINE,108)IA
!
!	IF(IA.EQ.'N')GO TO 13
	IF(.NOT.AcceptFilterDialog())GOTO 13
	CLOSE(IGRAPH)

      GO TO 26                !END OF STEARNS AND DAVID FILTER DESIGN

C SETUP FOR BUTTERWORTH HP-LP IF REQUESTED

200   DO I=1,20

       AH(I)=0D0

       BH(I)=0D0

       AL(I)=0D0

       BL(I)=0D0

       PVH(I)=0D0

       PVL(I)=0D0

      END DO  

C READ COEFFS

      IBH=17

      IAH=17

      IBL=17

      IAL=17

      K=1

      DO 205 I=1,IBH

       BH(I)=COEFF(K)

205    K=K+1

      DO 210 I=1,IAH

       AH(I)=COEFF(K)

210    K=K+1

      DO 215 I=1,IBL

       BL(I)=COEFF(K)

215    K=K+1

      DO 220 I=1,IAL

       AL(I)=COEFF(K)

220    K=K+1

C SETUP FOR INITIAL CONDS ON FILTER DELAYS

      NHFILT=MAX(IBH,IAH)

      DO 225 I=NHFILT,1,-1

225    PVH(I)=PVH(I+1)+BH(I)-AH(I)

      NLFILT=MAX(IBL,IAL)

      DO 226 I=NLFILT,1,-1

226    PVL(I)=PVL(I+1)+BL(I)-AL(I)

C FILTER DESIGN COMPLETE, DETERMINE DECIMATION ROUTINE

26    NDO1=NDO                         

!      IDEC=0
!
!      WRITE(*,110)
!
!110   FORMAT('$DECIMATE FILTERED DATA? >'\)
!
!	READ(*,108)IA
!
!	IF(IA.NE.'Y' .AND. IA.NE.'y')GO TO 28      

	IDEC=1

	ISO1=ISO

!	WRITE(*,111)ISO1
!
!111   FORMAT('$ENTER FINAL SAMPLE RATE (.LE. ',I4,') >'\)
!
!	READ(*,*)ISO

	IOFF=ISO1/ISO

	NDO=NDO/IOFF

28    RETURN



C RUNNING SECTION- FIRST COPY INPUT TO WORK AREA AND PREPEND INITIAL DATA

30    IF(IFILT.EQ.4)GO TO 228             !SKIP TO HP-LP

      NFACT=3*LS

      NDO2=NDO1+NFACT

      K=NFACT+1

      DO 35 L=1,NDO1

       CALL XVAL(L,XV,XI)

       WORK(K)=XV

35    K=K+1

      WK=2.*WORK(NFACT+1)

      DO 36 I=0,NFACT-1

36     WORK(NFACT-I)=WK-WORK(NFACT+2+I)

C APPLY THE FILTER

	PX=0.

	PY=0.

	CALL SPCFLT(B,A,LS,NS,WORK0,NDO2,PX,PY,IERR)

	IF(IERR.EQ.0)GO TO 40

!	WRITE(*,112)KNT,IBUF(1),IERR

112   FORMAT('$ERROR: RECSET',I5,' CHANNEL',I4,', SECTION',I2)

!	PAUSE ' <CR> TO CONTINUE'
	WRITE(ALINE,112)KNT,IBUF(1),IERR
      CALL ShowInfoText('Error',ALINE)

C APPEND AND REVERSE THE ORDER OF THE DATA

40    WK=2*WORK(NDO2)

      DO 41 I=1,NFACT

41     WORK(NDO2+I)=WK-WORK(NDO2-I)

      NDO2=NDO2+NFACT

      DO 45 I=1,NDO2/2

	 TEMP=WORK(I)

       WORK(I)=WORK(NDO2-I+1)

45     WORK(NDO2-I+1)=TEMP

C  NOW PASS THROUGH THE FILTER FOR A SECOND TIME

      PX=0.

      PY=0.

	CALL SPCFLT(B,A,LS,NS,WORK0,NDO2,PX,PY,IERR)

	IF(IERR.EQ.0)GO TO 50

!	WRITE(*,112)KNT,IBUF(1),IERR
!
!	PAUSE ' <CR> TO CONTINUE'
	WRITE(ALINE,112)KNT,IBUF(1),IERR
      CALL ShowInfoText('Error',ALINE)

C  REVERSE DATA AND DROP ENDS

50	DO 55 I=1,NDO2/2

       TEMP=WORK(I)

	 WORK(I)=WORK(NDO2-I+1)

55     WORK(NDO2-I+1)=TEMP

      DO 60 I=1,NDO1

60     WORK(I)=WORK(NFACT+I)

      GO TO 300

C RUNNING SECTION FOR HP-LP

228   NFACT=3*(NHFILT-1)

      NDO2=NDO1+NFACT

      K=NFACT+1

C READ DATA AND PREPEND IC'S      

      DO 230 L=1,NDO1

       CALL XVAL(L,XV,XI)

       WORK(K)=XV

230    K=K+1

      WK=2.*WORK(NFACT+1)

      DO 235 I=0,NFACT-1

235    WORK(NFACT-I)=WK-WORK(NFACT+2+I)

C IC'S FOR HP FILTER DELAYS       

      DO 240 I=2,NHFILT

240    ZI(I-1)=PVH(I)*WORK(1)

C FIRST PASS FOR HP

      CALL T2TFILT(BH,AH,IBH,IAH,WORK,NDO2,ZI,IERR)

      IF(IERR.EQ.0) GO TO 241

!      WRITE(*,113)KNT,IBUF(1)

113   FORMAT('$FILTER ERROR, RECSET',I5,' CHANNEL',I4)

!      PAUSE ' <CR> TO CONTINUE'
	WRITE(ALINE,113)KNT,IBUF(1)
      CALL ShowInfoText('Error',ALINE)

241   WK=2*WORK(NDO2)          

C APPEND DATA  IC'S

      DO 245 I=1,NFACT

245    WORK(NDO2+I)=WK-WORK(NDO2-I)

      NDO2=NDO2+NFACT

C FLIP  DATA      

      DO 250 I=1,NDO2/2

       TEMP=WORK(I)

       WORK(I)=WORK(NDO2-I+1)

250    WORK(NDO2-I+1)=TEMP   

C DELAY IC'S FOR FILTER

      DO 255 I=2,NHFILT

255    ZI(I-1)=PVH(I)*WORK(1)  

C HP SECOND PASS

      CALL T2TFILT(BH,AH,IBH,IAH,WORK,NDO2,ZI,IERR)

      IF(IERR.EQ.0)GO TO 260

!      WRITE(*,113)KNT,IBUF(1)

!      PAUSE ' <CR> TO CONTINUE'
	WRITE(ALINE,113)KNT,IBUF(1)
      CALL ShowInfoText('Error',ALINE)

C DELAY IC'S FOR LP FILTER     

260   DO 265 I=2,NLFILT

265    ZI(I-1)=PVL(I)*WORK(1)

C FIRST PASS LP

      CALL T2TFILT(BL,AL,IBL,IAL,WORK,NDO2,ZI,IERR)

      IF(IERR.EQ.0) GO TO 266

      WRITE(*,113)KNT,IBUF(1)

      PAUSE' <CR> TO CONTINUE'

C FLIP DATA      

266   DO 270 I=1,NDO2/2

       TEMP=WORK(I)

       WORK(I)=WORK(NDO2-I+1)

270    WORK(NDO2-I+1)=TEMP

C DELAY IC'S

      DO 275 I=2,NLFILT

275    ZI(I-1)=PVL(I)*WORK(1)

C SECOND PASS LP

      CALL T2TFILT(BL,AL,IBL,IAL,WORK,NDO2,ZI,IERR)

      IF(IERR.EQ.0)GO TO 276

      WRITE(*,113)KNT,IBUF(1)

      PAUSE' <CR> TO CONTINUE'  

C DROP PREPEND     

276   DO 280 I=1,NDO1

280    WORK(I)=WORK(NFACT+I)            

C COPY ID INFO, DECIMATE AND WRITE RECORD      

300   J=J1

	DO 310 I=1,NID

	 IBUFO(J)=IBUFO(I)

310     J=J+1

	IF(IDEC.EQ.0) GO TO 320

	L=1

	DO 315 J=2,NDO

	 L=L+IOFF

315    WORK(J)=WORK(L)

320   CALL PUTSTD(IBUFO(J1))

325   RETURN

	END

																												                          

                                                                                                                                                                                            

                                 

      SUBROUTINE FILPLOT(NS,LS,B,A,ISO)

C

C CALCULATE AND PLOT RESPONSE FOR STEARNS & DAVID CASCADED SECTIONS FILTERS

C

      COMPLEX Z1,BSUM,ASUM,GAIN

      DIMENSION B(0:LS,NS),A(LS,NS),AMP(0:1000),FREQ(0:1000)

      DATA NPT/500/

      SMALL=1.E-10

      BIG=1.E10    

      RSO=REAL(ISO)/(NPT*2)     

      DO 5 I=0,NPT

       AMP(I)=1.

5      FREQ(I)=I*RSO  

      DO 20 IS=1,NS

C GET MAG RESPONSE AT NPT NUM OF PTS AND 0 HZ                 

       DO 20 IM=0,NPT 

        Z1=CEXP(CMPLX(0.,-8.*ATAN(1.)*IM*.5/NPT))

        BSUM=0.

        DO 10 I=LS,1,-1

10       BSUM=(BSUM+B(I,IS))*Z1

        ASUM=0.

        DO 15 I=LS,1,-1

15       ASUM=(ASUM+A(I,IS))*Z1           

        IF(ABS(1.+ASUM).LT.SMALL) GAIN=BIG

        IF(ABS(1.+ASUM).GE.SMALL) GAIN=(B(0,IS)+BSUM)/(1.+ASUM)

C FOR CASCADED SECTIONS JUST MULTIPLY GAINS FOR EACH SECTION       

20      AMP(IM)=AMP(IM)*ABS(GAIN)    

C PLOT FREQ VS. AMP 

      CALL MPLOT(NPT+1,FREQ,AMP)

      RETURN

      END

                   

                   

      SUBROUTINE MPLOT(NPTS,X,Y)

C MONITOR X/Y PLOT ROUTINE WITH AUTO AXIS LABELS AND SCALING 

C NPTS = NUM OF POINTS PLOTTED

C X = ARRAY OF X VALUES

C Y = ARRAY OF Y VALUES

C 

C WJRD 10/30/94

C

      USE IFQWIN

C BASIC SCREEN DIMENSIONS FOR SELECTED VIDEO MODE      

!      PARAMETER (IXDIM=1024,IYDIM=768,MARGIN=10)   !SVGA      
      PARAMETER (MARGIN=10)   !SVGA      

      DIMENSION X(NPTS),Y(NPTS)

      INTEGER*2 ISTAT,IXM,IXX,IYM,IYX,IC,IR

      DOUBLE PRECISION XP,YP,XMIN,YMIN,XMAX,YMAX

      CHARACTER*3 XLAB,YLAB            

      CHARACTER*4 STR

      LOGICAL*2 TRU 

      RECORD /RCCOORD/ CPOS

      RECORD /WXYCOORD/ WXY

      DATA TRU/.TRUE./, XLAB/'HZ'/, YLAB/'MAG'/, NGRID/10/

      DATA ROWS/30/, COLS/80/            
	RECORD/QWINFO/ WINFO
	COMMON/DEV/ITI,ILP,IGRAPH
	LOGICAL Ltemp
	type(windowconfig) :: wco

C CALC WIDTH OF ROW AND COLS IN XY COORDINATES

      OPEN(UNIT=IGRAPH,FILE='USER',TITLE='PLOT')
      igraphHwnd=GetHwndQQ(IGRAPH)
      I=INITIALIZEFONTS()
	ISTAT=SETFONT("t'tms rmn'h18w9")
	I=SETTEXTCOLORRGB(Z'FFFFFF')
	WINFO%TYPE=QWIN$MAX
	I=SETWSIZEQQ(IGRAPH,WINFO)
      CALL MGetWindowSize(igraphHwnd,IW1,IH1)
      ixdim=IW1-32
      iydim=IH1-64
      Ltemp=GETWINDOWCONFIG(wco)
      COLS=ixdim/(1.*wco%numxpixels/wco%numtextcols)
      ROWS=iydim/(1.*wco%numypixels/wco%numtextrows)
      
      ICW=IXDIM/COLS

      IRW=IYDIM/ROWS

!      ISTAT=SETVIDEOMODEROWS($VRES2COLOR,ROWS)   !VGA MONO

!      ISTAT=SETVIDEOMODEROWS($XRES256COLOR,ROWS) !SVGA      

C SETUP VIEWPORT TO ALLOW ROOM FOR AXES LABELS 

      IXM=7*ICW-1

      IXX=IXDIM-3*ICW-1

      IYM=2*IRW-6

      IYX=IYDIM-3*IRW-3

      CALL CLEARSCREEN($GCLEARSCREEN)

      CALL SETVIEWPORT(IXM,IYM,IXX,IYX)

C GET MAX AND MIN VALUES OF DATA

      XMIN=X(1)

      YMIN=Y(1)

      XMAX=XMIN

      YMAX=YMIN

      DO I=2,NPTS

       XMIN=MIN(XMIN,X(I))

       YMIN=MIN(YMIN,Y(I))

       XMAX=MAX(XMAX,X(I))

       YMAX=MAX(YMAX,Y(I))

      END DO                                        

C DETERMINE GRID INCREMENT VALUES FOR X AND Y

      IXR=NINT(XMAX-XMIN)

      IYR=NINT(YMAX-YMIN)

      SELECT CASE (IXR)

      CASE (0:1)

       IXM=1

      CASE (2:5)

       IXM=5

      CASE (6:10)

       IXM=10

      CASE (11:20)

       IXM=20

      CASE (21:)

       IXM=50

      END SELECT           

      DO 10 WHILE (MOD(IXR,IXM).NE.0)

10     IXR=IXR+1

      SELECT CASE (IYR)

      CASE (0:1)

       IYM=1

      CASE (2:5)

       IYM=5

      CASE (6:10)

       IYM=10

      CASE (11:20)

       IYM=20

      CASE (21:)

       IYM=50

      END SELECT           

      DO 11 WHILE (MOD(IYR,IYM).NE.0)

11     IYR=IYR+1

      GRIDX=REAL(IXR)/NGRID

      GRIDY=REAL(IYR)/NGRID

C SET MAX AND MIN GRID VALUES

      IF(XMIN.LT.0)IXMIN=NINT(XMIN)

      IF(XMIN.GE.0)IXMIN=INT(XMIN)

      IF(YMIN.LT.0)IYMIN=NINT(YMIN)

      IF(YMIN.GE.0)IYMIN=INT(YMIN)

C      DO 15 WHILE (MOD(IXMIN,INT(GRIDX)).NE.0)

C15     IXMIN=IXMIN-1

C      DO 16 WHILE (MOD(IYMIN,INT(GRIDY)).NE.0)

C16     IYMIN=IYMIN-1

      XMIN=IXMIN

      XMAX=XMIN+IXR

      YMIN=IYMIN

      YMAX=YMIN+IYR

C SETUP A WINDOW IN THE VIEWPORT

      ISTAT=SETWINDOW(TRU,XMIN,YMAX,XMAX,YMIN)

C DRAW GRIDS, Y FIRST, THEN X 

      CALL MOVETO_W(XMIN,YMIN,WXY)  

      YP=YMIN

      DO 20 I=0,NGRID 

       ISTAT=LINETO_W(XMAX,YP)                               

       YP=YP+GRIDY

20     CALL MOVETO_W(XMIN,YP,WXY)

      CALL MOVETO_W(XMIN,YMIN,WXY)

      XP=XMIN

      DO 21 I=0,NGRID

       ISTAT=LINETO_W(XP,YMAX)

       XP=XP+GRIDX       

21     CALL MOVETO_W(XP,YMIN,WXY)

C PLOT DATA         

      XP=X(1)

      YP=Y(1)

      CALL MOVETO_W(XP,YP,WXY)

      DO 25 I=2,NPTS  

       XP=X(I)

       YP=Y(I)

25     ISTAT=LINETO_W(XP,YP)       

C LABEL GRIDS                         

      rstepx=(COLS-8)/NGRID
      rstepy=(ROWS-5)/NGRID*2

!      IR=ROWS-2
      IR=ROWS-1

      IC0=4       

      DO 30 I=0,NGRID
       ic=ic0+i*rstepx

       CALL SETTEXTPOSITION(IR,IC,CPOS)

       WRITE(STR,'(I4)') IXMIN+I*INT(GRIDX)

       CALL OUTTEXT(STR)                   

!30     IC=IC+7                                   
30     continue

      IR0=ROWS-10

!      IC=4
      IC=3

      DO 35 I=2,NGRID,2
       ir=ir0-(i/2-1)*rstepy

       CALL SETTEXTPOSITION(IR,IC,CPOS)

       WRITE(STR,'(F3.1)') IYMIN+I*GRIDY

       CALL OUTTEXT(STR)

!35     IR=IR-5
35    continue

      IR=ROWS-ROWS/2

      IC=2

      CALL SETTEXTPOSITION(IR,IC,CPOS)

      CALL OUTTEXT(YLAB) 

      IR=ROWS

      IC=COLS-COLS/4

      CALL SETTEXTPOSITION(IR,IC,CPOS)

      CALL OUTTEXT(XLAB)

      IR=1

      IC=COLS/4

      CALL SETTEXTPOSITION(IR,IC,CPOS)

!      CALL OUTTEXT(' ENTER <CR> TO CONTINUE-->')
!      CALL ShowInfoText('Pause',' ENTER <CR> TO CONTINUE-->')

!      READ(*,*)

      !CALL CLEARSCREEN($GCLEARSCREEN) 

!      ISTAT=SETVIDEOMODE($DEFAULTMODE)

      RETURN 

      END



