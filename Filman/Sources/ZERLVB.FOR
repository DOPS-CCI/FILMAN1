	SUBROUTINE ZERLVB(WORK,NCHANS,NDO1,NPTS,IMETH,IBMX,ITI,
     $                  R2,R1M,V,RCONST,IORD,IALG,Q,IPIV,KN,WHICH,
     $                  ZWYN,NPRVL,PRVL)
	INCLUDE 'MULTAR.INC'
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION WORK(NCHANS,NDO1)
	DIMENSION Q(MAXAR*NCHANS,NCHANS)
	DIMENSION V(NCHANS,NCHANS)
	DIMENSION R1M(NCHANS*MAXAR,NCHANS)
	DIMENSION R2(NCHANS*MAXAR,NCHANS*MAXAR)
	DIMENSION IPIV(NCHANS*MAXAR)
	DIMENSION RCONST(NCHANS,NCHANS,MAXAR+1)
	DIMENSION WYN(:,:,:,:),SWORK(:,:),IWORK1(:),IWORK2(:)
	DIMENSION ZWYN(NPRVL,NCHANS,NCHANS,MAXAR+1)
	REAL PRVL(NPRVL)
	REAL WYN,ZWYN
	ALLOCATABLE WYN,SWORK,IWORK1,IWORK2
      LOGICAL WHICH(MKN+1)
	CHARACTER*64 INPFIL
	COMMON/STDFIL/INPFIL
     
     
	ALLOCATE(WYN(NPTS,NCHANS,NCHANS,KN),STAT=IERR)
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'CANNOT ALLOCATE WORKSPACE (WYN/ZERLVB)'
	 GOTO 900
	ENDIF
	ALLOCATE(SWORK(NCHANS,NDO1),STAT=IERR)
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'CANNOT ALLOCATE WORKSPACE (SWORK/ZERLVB)'
	 GOTO 901
	ENDIF
	ALLOCATE(IWORK1(NDO1),STAT=IERR)
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'CANNOT ALLOCATE WORKSPACE (IWORK1/ZERLVB)'
	 GOTO 902
	ENDIF
	ALLOCATE(IWORK2(NDO1),STAT=IERR)
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'CANNOT ALLOCATE WORKSPACE (IWORK2/ZERLVB)'
	 GOTO 903
	ENDIF
	CALL INITZRBOT(INPFIL,NPTS,NCHANS)
	DO 1,IB=1,IBMX
	CALL SHOWPROGRESS(IB,IBMX,70,'z',ITI)
      CALL SHUFFLE(WORK,SWORK,NCHANS,NDO1,IWORK1,IWORK2,IMETH)
      CALL CCORR(SWORK,R2,R1M,V,RCONST,NCHANS,NDO1,IORD,IALG)
      CALL SOLVEARYWCOV(R2,Q,R1M,V,NCHANS,IORD,IPIV,IALG)
      CALL AR_SPECTT(Q,V,NCHANS,IORD,NCHANS*MAXAR,WYN,NPTS,KN)
      CALL SAVEZRBDTF(WYN,NPTS,NCHANS,KN,WHICH,IB)
1     CONTINUE
      CALL FINDZRPRC(ZWYN,WYN,PRVL,NPRVL,
     $               NPTS,NCHANS,KN,WHICH,
     $               IBMX,INPFIL)
      CALL CLOSEZRBOT


      DEALLOCATE(IWORK2)
903   DEALLOCATE(IWORK1)
902   DEALLOCATE(SWORK)
901   DEALLOCATE(WYN)
900   RETURN
      END
      

      
      SUBROUTINE SHUFFLE(WORK,SWORK,NCHANS,NDO1,IWORK1,ITRLON,IMETHOD)
      USE MKL_DFTI
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION WORK(NCHANS,NDO1),SWORK(NCHANS,NDO1)
      DIMENSION IWORK1(NDO1),ITRLON(NDO1)
C IMETHOD=1 RANDOM SHUFFLE DATA SAMPLES
C IMETHOD=2 RANDOMIZE PHASES (NOT READY YET)
      DIMENSION YFFT(:)
      ALLOCATABLE YFFT
      type(DFTI_DESCRIPTOR), POINTER :: My_FFT_Handle
      INTEGER STATUS
	PARAMETER (PI=3.14159265358979323846264338328D0)
      
      SELECT CASE(IMETHOD)
      CASE(1)
        DO 1,IC=1,NCHANS
        DO 11,IP=1,NDO1
11      IWORK1(IP)=IP      
        Do 2,IP=1,NDO1
        rin=real(NDO1-IP+1)
C      call random_number(x)   ! USE FORTRAN INTERNAL RNG
C      call RNUN(1,x)          ! USE IMSL RNG
        X=RNUNF()                ! USE IMSL RNG
        num=x*rin+1
        ITRLON(IP)=IWORK1(NUM)
        do 3,j=num+1,rin
3       IWORK1(j-1)=IWORK1(j)
2       CONTINUE
        DO 4,IP=1,NDO1
4       SWORK(IC,IP)=WORK(IC,ITRLON(IP))
1       CONTINUE
      CASE(2)
        ALLOCATE(YFFT(NCHANS*(NDO1+2)))
! Perform a real to complex conjugate-even transform
        Status = DftiCreateDescriptor(My_FFT_Handle, DFTI_DOUBLE,
     $      DFTI_REAL, 1, NDO1)
        Status = DftiSetValue(My_FFT_Handle, DFTI_FORWARD_SCALE, 1D0)
        Status = DftiSetValue(My_FFT_Handle, DFTI_BACKWARD_SCALE,
     $             1D0/dble(NDO1))
        Status = DftiSetValue(My_FFT_Handle, DFTI_NUMBER_OF_TRANSFORMS,
     $             NCHANS)
        Status = DftiSetValue(My_FFT_Handle, DFTI_INPUT_DISTANCE,NDO1+2)
        Status = DftiSetValue(My_FFT_Handle,DFTI_OUTPUT_DISTANCE,NDO1+2)
        Status = DftiCommitDescriptor(My_FFT_Handle)
        DO 12,IC=1,NCHANS
        YFFT((IC-1)*(NDO1+2)+1:IC*(NDO1+2)-2)=WORK(IC,:)
12      YFFT(IC*(NDO1+2)-1:IC*(NDO1+2))=0D0
        Status = DftiComputeForward(My_FFT_Handle, YFFT)
! result is given by YFFT in CCS format.
        DO 15,IC=1,NCHANS
C RANDOMIZING PHASES
        DO 21,I=2,(NDO1+2)/2
        IX=(IC-1)*(NDO1+2)+(I-1)*2+1
        R=HYPOT(YFFT(IX),YFFT(IX+1))
        X=RNUNF()
        X=2*PI*X
        YFFT(IX)=R*COS(X)
21      YFFT(IX+1)=R*SIN(X)
15      CONTINUE        
        Status = DftiComputeBackward(My_FFT_Handle, YFFT)
        Status = DftiFreeDescriptor(My_FFT_Handle)
        DO 16,IC=1,NCHANS
C BACK TO TIME DOMAIN
16      SWORK(IC,:)=YFFT((IC-1)*(NDO1+2)+1:IC*(NDO1+2)-2)
        DEALLOCATE(YFFT)
      END SELECT
      
      END

      SUBROUTINE FINDZRPRC(ZWYN,WYN,PRVL,LPRVL,
     $                     NPTS,NCHANS,KN,WHICH,
     $                     IBMX,INPFIL)
      !use ifport ! Do "time"
	INCLUDE 'MULTAR.INC'
      DIMENSION PRVL(LPRVL)
      DIMENSION ZWYN(LPRVL,NCHANS,NCHANS,KN)
      REAL WYN(NPTS,NCHANS,NCHANS,KN)
      REAL OBS(:),Q(:),XLO(:),XHI(:)
      ALLOCATABLE OBS,Q,XLO,XHI
	CHARACTER*(*) INPFIL
      LOGICAL WHICH(MKN+1)
	COMMON/DEV/ITI
      
      ALLOCATE(OBS(NPTS*IBMX),STAT=ierr)
      ALLOCATE(Q(LPRVL),STAT=ierr)
      ALLOCATE(XLO(LPRVL),STAT=ierr)
      ALLOCATE(XHI(LPRVL),STAT=ierr)

      !It1=time()
      Do 1,IK=1,KN
      Do 1,IR=1,NCHANS
      DO 1,IC=1,NCHANS
      IO=1
      CALL SHOWPROGRESS(((IK-1)*KN+(IR-1))*NCHANS+IC,
     $ KN*NCHANS*NCHANS,70,'Z',ITI)
      Do 3,IB=1,IBMX
      CALL GETZRDTF(WYN,NPTS,NCHANS,KN,WHICH,IB)
      DO 3,IP=1,NPTS
      OBS(IO)=WYN(IP,IR,IC,IK)
3     IO=IO+1      
      CALL EQTIL(IBMX*NPTS,OBS,LPRVL,PRVL,Q,XLO,XHI,NMISS)
      DO 5,IL=1,LPRVL
5     ZWYN(IL,IR,IC,IK)=Q(IL)
1     CONTINUE
      write(*,*)
      !it2=time()
      !write(*,*)it2-it1

      DEALLOCATE(XHI)
      DEALLOCATE(XLO)
      DEALLOCATE(Q)
      DEALLOCATE(OBS)
      RETURN
      
      END
      

	SUBROUTINE INITZRBOT(INPFIL,NPTS,NCHANS)
	CHARACTER*(*) INPFIL
	CHARACTER*1024 FNAME
      COMMON /ZRBOTFIL/ ICVN,IRECCN,IRECL,IERRCN
      
      ICVN=75
      IRECL=NPTS*NCHANS*NCHANS
      FNAME='C:\EEGDATA\'//INPFIL(1:LEN_TRIM(INPFIL))//'.ZRBOTSTR.TMP'
      OPEN(UNIT=ICVN,STATUS='REPLACE',FORM='UNFORMATTED',
     $     ACCESS='DIRECT',RECL=IRECL,ERR=10,IOSTAT=iostat,
     $     FILE=FNAME)
      IERRCN=0
      RETURN
10    IERRCN=iostat
      WRITE(*,*)'File ',FNAME(1:LEN_TRIM(FNAME)),' open error ',IERRCN
      RETURN
	END
     
      SUBROUTINE CLOSEZRBOT
      COMMON /ZRBOTFIL/ ICVN,IRECCN,IRECL,IERRCN
      
C      CLOSE(UNIT=ICVN)
      CLOSE(UNIT=ICVN,STATUS='DELETE')
      END
      
      SUBROUTINE SAVEZRBDTF(WYN,NPTS,NCHANS,KN,WHICH,IB)
	INCLUDE 'MULTAR.INC'
C      REAL WYN(NPTS,NCHANS,NCHANS,KN)
      REAL WYN(*)
      COMMON /ZRBOTFIL/ ICVN,IRECCN,IRECL,IERRCN
      LOGICAL WHICH(MKN+1)
      
      IF(IERRCN.NE.0)RETURN
      ILIM=NPTS*NCHANS*NCHANS
      INUMR1=(IB-1)*(KN)+1
      do 1,irec=1,KN
      WRITE(ICVN,REC=INUMR1,ERR=10,IOSTAT=iostat)
     $            (WYN(I),I=(irec-1)*ILIM+1,irec*ILIM)
    1 INUMR1=INUMR1+1  
      RETURN
10    IERRCN=iostat
      WRITE(*,*)'Write error ',IERRCN
      RETURN      
      END      
      
      SUBROUTINE GETZRDTF(WYN,NPTS,NCHANS,KN,WHICH,IB)
	INCLUDE 'MULTAR.INC'
C      REAL WYN(NPTS,NCHANS,NCHANS,KN)
      REAL WYN(*)
      COMMON /ZRBOTFIL/ ICVN,IRECCN,IRECL,IERRCN
      LOGICAL WHICH(MKN+1)
      
      IF(IERRCN.NE.0)RETURN
      ILIM=NPTS*NCHANS*NCHANS
      INUMR1=(IB-1)*(KN)+1
      do 1,irec=1,KN
!      READ(ICVN,REC=INUMR1,ERR=10,IOSTAT=iostat)
!     $            (WYN(I),I=(irec-1)*ILIM+1,irec*ILIM)
      READ(ICVN,REC=INUMR1,ERR=10,IOSTAT=iostat)
     $            WYN((irec-1)*ILIM+1:irec*ILIM)
      !write(*,*)inumr1,' read'
    1 INUMR1=INUMR1+1  
      RETURN
10    IERRCN=iostat
      WRITE(*,*)'Read error ',IERRCN
      RETURN      
      END

      