C FADPSP.FOR (SPECTR) FITS AR MODEL & CALCULATES FAD PARAMETERS CHANNEL-
C BY-CHANNEL USING THE METHOD OF FRANASZCZUK AND BLINOWSKA, LINEAR MODEL
C OF BRAIN ELECTRICAL ACTIVITY- EEG AS A SUPERPOSITION OF DAMPED
C OSCILLATORY MODES, BIOLOGICAL CYBERNETICS, 53:19-25,1985. 
	SUBROUTINE FADPSP(WORK,N,IC)
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	INCLUDE 'MULTAR.INC'
      INCLUDE 'MAX.INC'
	DIMENSION ISTART(ICHMAX,2)!,IBUFO(1),X(NROW,NCOL)
	REAL WORK,X,WYN,XDIM,YDIM,VALMX,COF,AN,AM,PM
	INTEGER RYSAIC
C      DIMENSION WORK[ALLOCATABLE](:,:)
	DIMENSION Q[ALLOCATABLE](:,:)
	DIMENSION V[ALLOCATABLE](:,:) 
	DIMENSION WYN(0:MAXAR/2+1,IFADNR+1,MCHANS)
	DIMENSION WORK(N,IC),COF(MAXAR+1),COFD(MAXAR+1)
C ORGANIZATION OF WYN: FOR EACH CHANNEL, ROW 0 CONTAINS INFORMATION
C ABOUT THE MODEL; WYN(0,1,.)=# POLES FOUND,WYN(0,2,.)=NYQUIST FREQ,
C WYN(0,3,.)=ERROR CODE, AND WYN(0,4,.)=MODEL ORDER USED. SUCCEEDING
C ROWS CONTAIN THE FAD PARAMETERS CALCULATED, CURRENTLY B=AMPLITUDE,
C BETA=DAMPING, PHI=PHASE, OMEGA=FREQUENCY, AND B*EXP(-BETA) WHICH IS
C CALCULATED ON THE FLY BY FAD_GRAPHICS.
	CHARACTER*1 INPFIL(64)
	CHARACTER*24 CLABEL
	DIMENSION ICLABS(6,MCHANS)!,ISTART(MCHANS,2)
	COMMON IFLAG1,IFLAG2,IFLAG3,KNT,ISZ,ICHAN(64),CLABEL(64)
	COMMON/PTLST/NLIST,LIST(2,72),NP1,NP2,NPTOT,P1,PT,DT,DF
	COMMON/DEV/ITI
	COMMON/STDFIL/INPFIL
	COMMON/FLDES/ NG,NA,NC,ND,NF,NL,NR,IS,IBUF(1)
	COMMON/FLDESO/ NGO,NAO,NCO,NDO,NFO,NLO,NRO,ISO,WK(1)
	COMMON /ARERR/ IERR
	EQUIVALENCE (ICLABS,CLABEL)
	EQUIVALENCE (X,IX)      ! AVOID CONVERTING REAL/INTEGER

	intrinsic log
	real log               ! Maciek

C      SAVE CLABEL,XDIM,YDIM,ISTART,IFAD,VALMX,MODE
C INITIALIZATION SECTION WITH USER DIALOGUE 
1     IERR=0
	CALL PTSEL
	NDO1=NPTOT    ! # SELECTED INPUT POINTS
2     WRITE(ITI,200)      
200   FORMAT('$  AR METHOD: 1=MULTAR/2=MODCOVAR >'\)
C	READ(ITI,*)METHOD
	READ(5,*)METHOD
3     WRITE(ITI,100)MAXAR
100   FORMAT('$AR MODEL ORDER (.LE.',I3,'; 0=ESTIMATE BEST) >'\)
C	READ(ITI,*)IORD0
	READ(5,*)IORD0
	CALL ZEROF(WYN,(MAXAR/2+1+1)*IFADNR*MCHANS)
	GO TO(20,30)METHOD
20    ALLOCATE(Q(NCO,MAXAR*NCO),STAT=IERR)
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (Q)'
	 STOP
	ENDIF 
	ALLOCATE(V(NCO,NCO),STAT=IERR)
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'MULTAR ERROR: CANNOT ALLOCATE WORKSPACE (V)'
	 STOP
	ENDIF 
C ORIGINAL FAD METHOD USING MULTAR      
	DO 25,ICH=1,IC
	IERR=0
	IORD=IORD0
!	CALL DZEROF(Q,1*1*MAXAR)      ! INITIALIZE STORAGE
!	CALL DZEROF(V,1*1)
	Q=0D0      ! INITIALIZE STORAGE
	V=0D0
	CALL DO_AR(WORK(NP1,ICH),NDO1,1,IORD,Q,V,MAXAR,1*MAXAR,1) !GETS COFS
	CALL DO_FAD(Q,WYN,ICH,IORD,LEN)   ! CALCULATES FAD PARMS FROM COFS
	IF(WYN(0,3,ICH).EQ.0.)GO TO 25     ! NO ERRORS
	WRITE(ITI,301)KNT,ICH,INT(WYN(0,3,ICH)),IORD
301   FORMAT('  ERROR AT RECSET',I4,' CHAN',I3,'; CODE=',I1,', ORD=',I2,
     + '; <CR> TO CONT. >'\)                              
C	READ(ITI,'(A1)')IA
	READ(5,'(A1)')IA
25    CONTINUE
	GO TO 60
C ALTERNATIVE METHOD USING MODCOVAR TO GET THE AR COEFFICIENTS
30    DO 50 ICH=1,IC
	IORD=IORD0
	IF(IORD.NE.0)GO TO 40
C USE RYSAIC TO IDENTIFY BEST MODEL ORDER
	DO 35 M=1,MAXAR
	CALL MODCOV(NPTOT,M,WORK(NP1,ICH),PM,COF,ISTAT,1)
	AN=NPTOT
	AM=M+1
	IF(PM.LT.1.0)PM=1.0
c	COFD(M)=(AN*ALOG(PM)+2.0*(AM-1.0))/1000.
	COFD(M)=(AN*LOG(PM)+2.0*(AM-1.0))/1000.     !  Maciek
35    CONTINUE
	IORD=RYSAIC(COFD,MAXAR)
40    CALL MODCOV(NPTOT,IORD,WORK(NP1,ICH),PM,COF,ISTAT,1)
	DO 45 I=1,IORD
45    COFD(I)=DBLE(COF(I))
	CALL DO_FAD(COFD,WYN,ICH,IORD,LEN)
C CHECK FOR FAD/AR ERRORS HERE
50    CONTINUE
C PLOT ALL RESULTS FOR THIS RECSET, DOING EACH PARAMETER IN TURN IN
C MULTICHANNEL FORMAT AND SCALED TO MAX VALUE IN ARRAY.
60     IFAD=0
	 VALMX=0.
C SET UP FOR FAD GRAPHICS
	 IERR=0
	CALL GRAPHMODE_ON(MAXX,MAXY,NTR,NTC,NBBP,NCOLOR,0)
	IF(IERR.NE.0)STOP
	CALL SETUP(MAXX,MAXY,NTR,CLABEL,NCO,2,ISTART,XDIM,YDIM)
	MODE=1      ! FAD_GRAPHICS PLOTS EACH PARAMETER IN TURN
55    CALL CALCBBETA(WYN,NCO)
	CALL FAD_GRAPHICS(MODE,WYN,LEN,NCO,CLABEL,IFAD,ISTART,INT(XDIM),
     $                  INT(YDIM),MAXX,MAXY,VALMX)
	CALL GRAPHMODE_OFF
	WRITE(ITI,600)
600   FORMAT('$  FADPSP:<CR>=RETURN/1=ORDER/2=AR METHOD/3=POINTS >'\)
C	READ(ITI,'(I1)')IGO
	READ(5,'(I1)')IGO
C TERMINATION PHASE
	IF(METHOD.EQ.2)GO TO 85
	DEALLOCATE(V)
	DEALLOCATE(Q)
85    IERR=0
	GO TO(99,3,2,1)IGO+1
99    RETURN
	END

C*************************************************************************

	SUBROUTINE DO_FAD(Q,WYN,IC,IORD,LEN)
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	INCLUDE 'MULTAR.INC'
	DIMENSION Q(MAXAR+1)
	DIMENSION DN(MAXAR+1)
	DIMENSION BE(MAXAR),BETA(MAXAR),OMEGA(MAXAR),FI(MAXAR)
	DOUBLE PRECISION B(MAXAR+1),POL(MAXAR+1),RR(MAXAR+1),RC(MAXAR+1)
	DIMENSION WYN(0:MAXAR/2+1,IFADNR+1,MCHANS)
	REAL WYN,FP
	COMMON /ARERR/ IERR
	COMMON /FLDES/ NG,NA,NC,ND,NF,NL,NR,IS,IBUF(1)
	COMMON /DEV/ ITI

	IF(IERR.NE.0)THEN
	 WYN(0,3,IC)=1.   ! AN AR ERROR OCCURRED
	 RETURN
	ENDIF
	WYN(0,4,IC)=IORD  ! SET MODEL ORDER FOR ERROR TRACING
	RR(1)=1D0
	DO 1 I=2,IORD+1
    1 RR(I)=Q(I-1)      ! RR=(0,COF1,....,COFIORD)

	CALL DPRQD(B,IORD+1,RR,RC,POL,IR,IERR)  ! ROOTS RR POLYNOMIAL
	IF(IERR.NE.0)THEN
	 WRITE(ITI,*)'FAD ERROR'
	 WYN(0,3,IC)=2.
	 RETURN 
	ENDIF
	CALL RES(Q,DN,RR,RC,IR) ! FORMS Cjreal AND Cjimag FROM ROOTS
	CALL MODREZ(Q,DN,RR,RC,BE,BETA,OMEGA,FI,IR,LEN) ! FORMS FAD PARMS

	FP=REAL(IS)
	WYN(0,1,IC)=LEN
	WYN(0,2,IC)=FP*0.5
	DO 2,I=1,LEN
	WYN(I,1,IC)=BE(I)
	WYN(I,2,IC)=-BETA(I)
	WYN(I,3,IC)=FI(I)
    2 WYN(I,4,IC)=OMEGA(I)*FP
	
	END
	
	SUBROUTINE RES(A,B,X,Y,N)
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	DIMENSION X(N),Y(N),A(N),B(N)
	COMPLEX*16 Z,ZJ
	N1=1-N
	DO 10 J=1,N
	ZJ=CMPLX(X(J),Y(J))
	Z=ZJ**N1
	DO 20 I=1,N
	IF(I-J) 1,20,1
   1  Z=Z*(ZJ-CMPLX(X(I),Y(I)))
   20 CONTINUE
	Z=1D0/Z
	A(J)=DBLE(Z)
	B(J)=DIMAG(Z)
	IF(Y(J).EQ.0D0)B(J)=0D0
   10 CONTINUE
	END

	SUBROUTINE MODREZ(CR,CI,ZR,ZI,B,BETA,OMEGA,FI,N,M)
	IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	DIMENSION CR(N),CI(N),ZR(N),ZI(N)
	double precision zr,zi
	DIMENSION B(N),BETA(N),FI(N),OMEGA(N)
	COMPLEX*16 ALFA
	DATA PI /3.14159265358979323846264338328D0/
	M=0
	DO 10 I=1,N
	IF(CI(I))10,20,5
    5 M=M+1
	B(M)=2D0*CABS(CMPLX(CR(I),CI(I)))
	FI(M)=ATAN2(CI(I),CR(I))/PI+.5D0-SIGN(.5D0,CR(I))
	ALFA=CLOG(CMPLX(ZR(I),ZI(I)))
	BETA(M)=REAL(ALFA)
	OMEGA(M)=.5D0*ABS(AIMAG(ALFA))/PI
	FI(M)=SIGN(FI(M),AIMAG(ALFA))
	GOTO 10
   20 CONTINUE
	M=M+1
	B(M)=ABS(CR(I))
	FI(M)=.5D0-SIGN(.5D0,CR(I))
c	BETA(M)=ALOG(ABS(ZR(I)))
	BETA(M)=LOG(ABS(ZR(I)))     !  Maciek
	OMEGA(M)=.25D0-SIGN(.25D0,ZR(I))
   10 CONTINUE
	M1=M-1
	DO 50 I=1,M1
	MI=M-I
	DO 50 J=1,MI
	IF(OMEGA(J).LE.OMEGA(J+1))GOTO 50
	X=OMEGA(J)
	OMEGA(J)=OMEGA(J+1)
	OMEGA(J+1)=X
	X=B(J)
	B(J)=B(J+1)
	B(J+1)=X
	X=BETA(J)
	BETA(J)=BETA(J+1)
	BETA(J+1)=X
	X=FI(J)
	FI(J)=FI(J+1)
	FI(J+1)=X
   50 CONTINUE
	RETURN
	END
C *****************
