C FILTER.FOR- FILMAN GENERAL-PURPOSE DIGITAL FILTERING ROUTINE.

C 

C ALLOWS CONSTRUCTION OF WIDE VARIETY OF CHEBY1, CHEB2, & BUTTERWORTH FILTERS

C FOR LOWPASS, HIGHPASS, BANDPASS, OR BANDSTOP FILTERING, BASED ON STEARNS &

C DAVID CHS 6 &7. ALSO IMPLEMENTS BUTTERWORTH HP-LP SEQUENTIAL FILTERING FOR

C IMPROVED BANDPASS RESPONSE, USING DIRECT TYPE II TRANSPOSED FILTER WITH

C COEFFICIENTS GENERATED BY MATLAB M-FILE BHPLP. FORWARD/BACKWARD FILTERING 

C TO ELIMINATE PHASE SHIFTS, AND PREPENDING OF REFLECTED SEGMENTS TO DATA TO 

C MINIMIZE EDGE EFFECTS ARE USED IN ALL FILTERS. ADDITIONAL INITIAL CONDITIONS

C OF FILTER DELAYS (STATES) ARE INCLUDED WITH THE HP-LP FILTER TO REDUCE DC

C OFFSET EFFECTS. OPTIONAL DECIMATION OF FILTER OUTPUT AVAILABLE. 

C POSSIBLE FURTHER ENHANCEMENTS MIGHT INCLUDE ADDITION OF AT LEAST ONE 

C OPTIONAL FILTER SO AS TO PERMIT EXTRACTION OF 2 OR MORE HARMONICS BY 

C COMBINATION OF BRACKETING BANDPASS WITH LIMITING BANDSTOP FILTERS. 

C THIS VERSION OF FILTER.FOR UPDATED ON 10/31/94 

	SUBROUTINE FILTER

	USE IFQWIN

	INCLUDE 'MAX.INC'

	DOUBLE PRECISION COEFF(68),ZI(20)

	DIMENSION WORK(65536),WORK0(0:65535),CF(4),PX(0:4,6),PY(4,6)

      INTEGER*4, SAVE :: IFILT,LS,NDO1,NHFILT,NLFILT,IBH,IAH,IBL,IAL

      INTEGER*4, SAVE :: IOFF,NID,J1,IDEC,NS

      REAL*4, SAVE :: A(4,6),B(0:4,6)

      REAL*8, SAVE :: AH(20),BH(20),AL(20),BL(20),PVH(20),PVL(20)

	COMMON IFLAG1,IFLAG2,IFLAG3,KNT,ISZ,ICHAN(ICHMAX)

	COMMON/FLDESO/ NGO,NAO,NCO,NDO,NFO,NLO,NRO,ISO,IBUFO(IOMAX)

	COMMON/FLDES/ NG,NA,NC,ND,NF,NL,NR,IS,IBUF(IOMAX)

	EQUIVALENCE (WORK,IBUFO(121)),(WORK,WORK0)

	EQUIVALENCE (CF1,CF(1)),(CF2,CF(2)),(CF3,CF(3)),(CF4,CF(4))

	IF(IFLAG1) 10,30,325

10    NFO=3 ! DECIDED TO MAKE OUTPUT ALWAYS REAL TO AVOID QUANTIZATION

C MOVE OUTPUT CHANNEL LABELS

	J=6*NGO+109             ! OF LOW-POWER FILTER OUTPUTS

	DO 12 I=1,NCO

	 L=J+5

	 K=6*(NG+ICHAN(I))-5

	 DO 5 I1=J,L

	  IBUFO(I1)=IBUF(K)

5       K=K+1

12     J=J+6

	ISZ=120+NDO

	NID=NGO+NAO

	J1=120-NID+1  ! FIRST WORD OF OUTPUT RECORD

C DESIGN DIGITAL FILTER  

13    WRITE(*,100)

100   FORMAT('$FILTER TYPE:1=CHEBY1/2=CHEBY2/3=BUTTERWORTH >'\)
	READ(*,*)IFILT

	IF(IFILT.LT.1 .OR. IFILT.GT.3)GO TO 13

14    LS=4  ! LENGTH OF THE FILTER SECTIONS FOR STEARNS AND DAVID'S ROUTINES

	WRITE(*,101) !GET FILTER TYPE FOR STEARNS AND DAVID

101   FORMAT('$CHARACTERISTIC:1=LOWPASS/2=HIGHPASS/3=BANDPASS/',

     + '4=BANDSTOP >'\)

	READ(*,*)IBAND

	IF(IBAND.LT.1 .OR. IBAND.GT.4)GO TO 14

	IF(IBAND.LT.3)LS=2            

	WRITE(*,102)

102   FORMAT('$LOWER, UPPER CRITICAL FREQS(SEE S&D P.325) >'\)      

	READ(*,*)(CF(I),I=1,4)

C CONVERT TO HZ-SECONDS FOR DESIGN ROUTINES

	DO 16 I=1,4

16     CF(I)=CF(I)/FLOAT(ISO)

	WRITE(*,103)

103   FORMAT('$# FILTER SECTIONS(.LE.6), REJECTION IN DB(>3) >'\)

	READ(*,*)NS,DB

	CALL SPIIRD(IFILT,IBAND,NS,LS,CF1,CF2,CF3,CF4,DB,B,A,IERR)

	IF(IERR.EQ.0)GO TO 20

	WRITE(*,104)IERR

104   FORMAT(' DESIGN PROBLEM #',I3,'; REDO SPECS(SEE S&D P.153)')

	GO TO 13

C PLOT FILTER RESPONSE

20    CALL FILPLOT(NS,LS,B,A,ISO)

	WRITE(*,107)

107   FORMAT('$OK? >'\)

	READ(*,108)IA

108   FORMAT(A1)

	IF(IA.EQ.'N')GO TO 13

      GO TO 26                !END OF STEARNS AND DAVID FILTER DESIGN

C FILTER DESIGN COMPLETE, DETERMINE DECIMATION ROUTINE

26    NDO1=NDO                         

      IDEC=0

      WRITE(*,110)

110   FORMAT('$DECIMATE FILTERED DATA? >'\)

	READ(*,108)IA

	IF(IA.NE.'Y' .AND. IA.NE.'y')GO TO 28      

	IDEC=1

	ISO1=ISO

	WRITE(*,111)ISO1

111   FORMAT('$ENTER FINAL SAMPLE RATE (.LE. ',I4,') >'\)

	READ(*,*)ISO

	IOFF=ISO1/ISO

	NDO=NDO/IOFF

28    RETURN



C RUNNING SECTION- FIRST COPY INPUT TO WORK AREA AND PREPEND INITIAL DATA

30    NFACT=3*LS
      NDO2=NDO1+NFACT

      K=NFACT+1

      DO 35 L=1,NDO1

       CALL XVAL(L,XV,XI)

       WORK(K)=XV

35    K=K+1

      WK=2.*WORK(NFACT+1)

      DO 36 I=0,NFACT-1

36     WORK(NFACT-I)=WK-WORK(NFACT+2+I)

C APPLY THE FILTER

	PX=0.

	PY=0.

	CALL SPCFLT(B,A,LS,NS,WORK0,NDO2,PX,PY,IERR)

	IF(IERR.EQ.0)GO TO 40

	WRITE(*,112)KNT,IBUF(1),IERR

112   FORMAT('$ERROR: RECSET',I5,' CHANNEL',I4,', SECTION',I2)

	PAUSE ' <CR> TO CONTINUE'

C APPEND AND REVERSE THE ORDER OF THE DATA

40    WK=2*WORK(NDO2)

      DO 41 I=1,NFACT

41     WORK(NDO2+I)=WK-WORK(NDO2-I)

      NDO2=NDO2+NFACT

      DO 45 I=1,NDO2/2

	 TEMP=WORK(I)

       WORK(I)=WORK(NDO2-I+1)

45     WORK(NDO2-I+1)=TEMP

C  NOW PASS THROUGH THE FILTER FOR A SECOND TIME

      PX=0.

      PY=0.

	CALL SPCFLT(B,A,LS,NS,WORK0,NDO2,PX,PY,IERR)

	IF(IERR.EQ.0)GO TO 50

	WRITE(*,112)KNT,IBUF(1),IERR

	PAUSE ' <CR> TO CONTINUE'

C  REVERSE DATA AND DROP ENDS

50	DO 55 I=1,NDO2/2

       TEMP=WORK(I)

	 WORK(I)=WORK(NDO2-I+1)

55     WORK(NDO2-I+1)=TEMP

      DO 60 I=1,NDO1

60     WORK(I)=WORK(NFACT+I)

      GO TO 300

C COPY ID INFO, DECIMATE AND WRITE RECORD      

300   J=J1

	DO 310 I=1,NID

	 IBUFO(J)=IBUFO(I)

310     J=J+1

	IF(IDEC.EQ.0) GO TO 320

	L=1

	DO 315 J=2,NDO

	 L=L+IOFF

315    WORK(J)=WORK(L)

320   CALL PUTSTD(IBUFO(J1))

325   RETURN

	END

      SUBROUTINE FILPLOT(NS,LS,B,A,ISO)

C

C CALCULATE AND PLOT RESPONSE FOR STEARNS & DAVID CASCADED SECTIONS FILTERS

C

      COMPLEX Z1,BSUM,ASUM,GAIN

      DIMENSION B(0:LS,NS),A(LS,NS),AMP(0:1000),FREQ(0:1000)

      DATA NPT/500/

      SMALL=1.E-10

      BIG=1.E10    

      RSO=REAL(ISO)/(NPT*2)     

      DO 5 I=0,NPT

       AMP(I)=1.

5      FREQ(I)=I*RSO  

      DO 20 IS=1,NS

C GET MAG RESPONSE AT NPT NUM OF PTS AND 0 HZ                 

       DO 20 IM=0,NPT 

        Z1=CEXP(CMPLX(0.,-8.*ATAN(1.)*IM*.5/NPT))

        BSUM=0.

        DO 10 I=LS,1,-1

10       BSUM=(BSUM+B(I,IS))*Z1

        ASUM=0.

        DO 15 I=LS,1,-1

15       ASUM=(ASUM+A(I,IS))*Z1           

        IF(ABS(1.+ASUM).LT.SMALL) GAIN=BIG

        IF(ABS(1.+ASUM).GE.SMALL) GAIN=(B(0,IS)+BSUM)/(1.+ASUM)

C FOR CASCADED SECTIONS JUST MULTIPLY GAINS FOR EACH SECTION       

20      AMP(IM)=AMP(IM)*ABS(GAIN)    

C PLOT FREQ VS. AMP 

      CALL MPLOT(NPT+1,FREQ,AMP)

      RETURN

      END

                   

                   

      SUBROUTINE MPLOT(NPTS,X,Y)

C MONITOR X/Y PLOT ROUTINE WITH AUTO AXIS LABELS AND SCALING 

C NPTS = NUM OF POINTS PLOTTED

C X = ARRAY OF X VALUES

C Y = ARRAY OF Y VALUES

C 

C WJRD 10/30/94

C

      USE IFQWIN

C BASIC SCREEN DIMENSIONS FOR SELECTED VIDEO MODE      

      PARAMETER (IXDIM=1024,IYDIM=768,MARGIN=10)   !SVGA      

      DIMENSION X(NPTS),Y(NPTS)

      INTEGER*2 ISTAT,IXM,IXX,IYM,IYX,IC,IR

      DOUBLE PRECISION XP,YP,XMIN,YMIN,XMAX,YMAX

      CHARACTER*3 XLAB,YLAB            

      CHARACTER*4 STR

      LOGICAL*2 TRU 

      RECORD /RCCOORD/ CPOS

      RECORD /WXYCOORD/ WXY

      DATA TRU/.TRUE./, XLAB/'HZ'/, YLAB/'MAG'/, NGRID/10/

      DATA ROWS/30/, COLS/80/            

C CALC WIDTH OF ROW AND COLS IN XY COORDINATES

      ICW=IXDIM/COLS

      IRW=IYDIM/ROWS

C SETUP VIEWPORT TO ALLOW ROOM FOR AXES LABELS 

      IXM=7*ICW-1

      IXX=IXDIM-3*ICW-1

      IYM=2*IRW-6

      IYX=IYDIM-3*IRW-3

      CALL CLEARSCREEN($GCLEARSCREEN)

      CALL SETVIEWPORT(IXM,IYM,IXX,IYX)

C GET MAX AND MIN VALUES OF DATA

      XMIN=X(1)

      YMIN=Y(1)

      XMAX=XMIN

      YMAX=YMIN

      DO I=2,NPTS

       XMIN=MIN(XMIN,X(I))

       YMIN=MIN(YMIN,Y(I))

       XMAX=MAX(XMAX,X(I))

       YMAX=MAX(YMAX,Y(I))

      END DO                                        

C DETERMINE GRID INCREMENT VALUES FOR X AND Y

      IXR=NINT(XMAX-XMIN)

      IYR=NINT(YMAX-YMIN)

      SELECT CASE (IXR)

      CASE (0:1)

       IXM=1

      CASE (2:5)

       IXM=5

      CASE (6:10)

       IXM=10

      CASE (11:20)

       IXM=20

      CASE (21:)

       IXM=50

      END SELECT           

      DO 10 WHILE (MOD(IXR,IXM).NE.0)

10     IXR=IXR+1

      SELECT CASE (IYR)

      CASE (0:1)

       IYM=1

      CASE (2:5)

       IYM=5

      CASE (6:10)

       IYM=10

      CASE (11:20)

       IYM=20

      CASE (21:)

       IYM=50

      END SELECT           

      DO 11 WHILE (MOD(IYR,IYM).NE.0)

11     IYR=IYR+1

      GRIDX=REAL(IXR)/NGRID

      GRIDY=REAL(IYR)/NGRID

C SET MAX AND MIN GRID VALUES

      IF(XMIN.LT.0)IXMIN=NINT(XMIN)

      IF(XMIN.GE.0)IXMIN=INT(XMIN)

      IF(YMIN.LT.0)IYMIN=NINT(YMIN)

      IF(YMIN.GE.0)IYMIN=INT(YMIN)

      XMIN=IXMIN

      XMAX=XMIN+IXR

      YMIN=IYMIN

      YMAX=YMIN+IYR

C SETUP A WINDOW IN THE VIEWPORT

      ISTAT=SETWINDOW(TRU,XMIN,YMAX,XMAX,YMIN)

C DRAW GRIDS, Y FIRST, THEN X 

      CALL MOVETO_W(XMIN,YMIN,WXY)  

      YP=YMIN

      DO 20 I=0,NGRID 

       ISTAT=LINETO_W(XMAX,YP)                               

       YP=YP+GRIDY

20     CALL MOVETO_W(XMIN,YP,WXY)

      CALL MOVETO_W(XMIN,YMIN,WXY)

      XP=XMIN

      DO 21 I=0,NGRID

       ISTAT=LINETO_W(XP,YMAX)

       XP=XP+GRIDX       

21     CALL MOVETO_W(XP,YMIN,WXY)

C PLOT DATA         

      XP=X(1)

      YP=Y(1)

      CALL MOVETO_W(XP,YP,WXY)

      DO 25 I=2,NPTS  

       XP=X(I)

       YP=Y(I)

25     ISTAT=LINETO_W(XP,YP)       

C LABEL GRIDS                         

      IR=ROWS-2

      IC=8       

      DO 30 I=0,NGRID

       CALL SETTEXTPOSITION(IR,IC,CPOS)

       WRITE(STR,'(I4)') IXMIN+I*INT(GRIDX)

       CALL OUTTEXT(STR)                   

30     IC=IC+11
      IR=ROWS-8

      IC=4

      DO 35 I=2,NGRID,2

       CALL SETTEXTPOSITION(IR,IC,CPOS)

       WRITE(STR,'(F3.1)') IYMIN+I*GRIDY

       CALL OUTTEXT(STR)

35     IR=IR-5

      IR=ROWS-ROWS/2

      IC=2

      CALL SETTEXTPOSITION(IR,IC,CPOS)

      CALL OUTTEXT(YLAB) 

      IR=ROWS

      IC=COLS-COLS/4

      CALL SETTEXTPOSITION(IR,IC,CPOS)

      CALL OUTTEXT(XLAB)

      IR=1

      IC=COLS/4

      CALL SETTEXTPOSITION(IR,IC,CPOS)

      CALL OUTTEXT(' ENTER <CR> TO CONTINUE-->')

      READ(*,*)

      CALL CLEARSCREEN($GCLEARSCREEN) 

!      ISTAT=SETVIDEOMODE($DEFAULTMODE)

      RETURN 

      END



